/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fapp%2Fclient.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fpublic%2FIphone.png&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fpublic%2FiPhone%2012%20Pro.png&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fpublic%2FalgeriaMap.png&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Flink.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fapp%2FBackground.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fapp%2FStripe.js&server=false!":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fapp%2Fclient.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fpublic%2FIphone.png&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fpublic%2FiPhone%2012%20Pro.png&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fpublic%2FalgeriaMap.png&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Flink.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fapp%2FBackground.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fapp%2FStripe.js&server=false! ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/image-component.js */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/client.js */ \"(app-pages-browser)/./app/client.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./public/Iphone.png */ \"(app-pages-browser)/./public/Iphone.png\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./public/iPhone 12 Pro.png */ \"(app-pages-browser)/./public/iPhone 12 Pro.png\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./public/algeriaMap.png */ \"(app-pages-browser)/./public/algeriaMap.png\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/link.js */ \"(app-pages-browser)/./node_modules/next/dist/client/link.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/Background.js */ \"(app-pages-browser)/./app/Background.js\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/Stripe.js */ \"(app-pages-browser)/./app/Stripe.js\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRmFkbWluJTJGcmVwb3MlMkZTVVJWSVNJT04tbGFuZGluZy1wYWdlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZpbWFnZS1jb21wb25lbnQuanMmbW9kdWxlcz0lMkZVc2VycyUyRmFkbWluJTJGcmVwb3MlMkZTVVJWSVNJT04tbGFuZGluZy1wYWdlJTJGYXBwJTJGY2xpZW50LmpzJm1vZHVsZXM9JTJGVXNlcnMlMkZhZG1pbiUyRnJlcG9zJTJGU1VSVklTSU9OLWxhbmRpbmctcGFnZSUyRnB1YmxpYyUyRklwaG9uZS5wbmcmbW9kdWxlcz0lMkZVc2VycyUyRmFkbWluJTJGcmVwb3MlMkZTVVJWSVNJT04tbGFuZGluZy1wYWdlJTJGcHVibGljJTJGaVBob25lJTIwMTIlMjBQcm8ucG5nJm1vZHVsZXM9JTJGVXNlcnMlMkZhZG1pbiUyRnJlcG9zJTJGU1VSVklTSU9OLWxhbmRpbmctcGFnZSUyRnB1YmxpYyUyRmFsZ2VyaWFNYXAucG5nJm1vZHVsZXM9JTJGVXNlcnMlMkZhZG1pbiUyRnJlcG9zJTJGU1VSVklTSU9OLWxhbmRpbmctcGFnZSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGbGluay5qcyZtb2R1bGVzPSUyRlVzZXJzJTJGYWRtaW4lMkZyZXBvcyUyRlNVUlZJU0lPTi1sYW5kaW5nLXBhZ2UlMkZhcHAlMkZCYWNrZ3JvdW5kLmpzJm1vZHVsZXM9JTJGVXNlcnMlMkZhZG1pbiUyRnJlcG9zJTJGU1VSVklTSU9OLWxhbmRpbmctcGFnZSUyRmFwcCUyRlN0cmlwZS5qcyZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLG9PQUErSDtBQUMvSCx3SkFBNEY7QUFDNUYsZ0tBQWdHO0FBQ2hHLDhLQUF1RztBQUN2Ryx3S0FBb0c7QUFDcEcsOE1BQW9IO0FBQ3BILGdLQUFnRztBQUNoRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2JmOTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvYWRtaW4vcmVwb3MvU1VSVklTSU9OLWxhbmRpbmctcGFnZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS1jb21wb25lbnQuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9hZG1pbi9yZXBvcy9TVVJWSVNJT04tbGFuZGluZy1wYWdlL2FwcC9jbGllbnQuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9hZG1pbi9yZXBvcy9TVVJWSVNJT04tbGFuZGluZy1wYWdlL3B1YmxpYy9JcGhvbmUucG5nXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvYWRtaW4vcmVwb3MvU1VSVklTSU9OLWxhbmRpbmctcGFnZS9wdWJsaWMvaVBob25lIDEyIFByby5wbmdcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9hZG1pbi9yZXBvcy9TVVJWSVNJT04tbGFuZGluZy1wYWdlL3B1YmxpYy9hbGdlcmlhTWFwLnBuZ1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2FkbWluL3JlcG9zL1NVUlZJU0lPTi1sYW5kaW5nLXBhZ2Uvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvbGluay5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2FkbWluL3JlcG9zL1NVUlZJU0lPTi1sYW5kaW5nLXBhZ2UvYXBwL0JhY2tncm91bmQuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9hZG1pbi9yZXBvcy9TVVJWSVNJT04tbGFuZGluZy1wYWdlL2FwcC9TdHJpcGUuanNcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fapp%2Fclient.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fpublic%2FIphone.png&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fpublic%2FiPhone%2012%20Pro.png&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fpublic%2FalgeriaMap.png&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Flink.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fapp%2FBackground.js&modules=%2FUsers%2Fadmin%2Frepos%2FSURVISION-landing-page%2Fapp%2FStripe.js&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/Stripe.js":
/*!***********************!*\
  !*** ./app/Stripe.js ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction Stripe() {\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        /*\n     *   Stripe WebGl Gradient Animation by Stripe.com\n     *   ScrollObserver functionality to disable animation when not scrolled into view has been disabled and\n     *   commented out for now.\n     */ //Converting colors to proper format\n        function normalizeColor(hexCode) {\n            return [\n                (hexCode >> 16 & 255) / 255,\n                (hexCode >> 8 & 255) / 255,\n                (255 & hexCode) / 255\n            ];\n        }\n        [\n            \"SCREEN\",\n            \"LINEAR_LIGHT\"\n        ].reduce((hexCode, t, n)=>Object.assign(hexCode, {\n                [t]: n\n            }), {});\n        //Essential functionality of WebGl\n        //t = width\n        //n = height\n        class MiniGl {\n            setSize() {\n                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 640, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 480;\n                this.width = e, this.height = t, this.canvas.width = e, this.canvas.height = t, this.gl.viewport(0, 0, e, t), this.commonUniforms.resolution.value = [\n                    e,\n                    t\n                ], this.commonUniforms.aspectRatio.value = e / t, this.debug(\"MiniGL.setSize\", {\n                    width: e,\n                    height: t\n                });\n            }\n            //left, right, top, bottom, near, far\n            setOrthographicCamera() {\n                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -2e3, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2e3;\n                this.commonUniforms.projectionMatrix.value = [\n                    2 / this.width,\n                    0,\n                    0,\n                    0,\n                    0,\n                    2 / this.height,\n                    0,\n                    0,\n                    0,\n                    0,\n                    2 / (i - s),\n                    0,\n                    e,\n                    t,\n                    n,\n                    1\n                ], this.debug(\"setOrthographicCamera\", this.commonUniforms.projectionMatrix.value);\n            }\n            render() {\n                this.gl.clearColor(0, 0, 0, 0), this.gl.clearDepth(1), this.meshes.forEach((e)=>e.draw());\n            }\n            constructor(canvas, width, height, debug = false){\n                const _miniGl = this, debug_output = -1 !== document.location.search.toLowerCase().indexOf(\"debug=webgl\");\n                _miniGl.canvas = canvas, _miniGl.gl = _miniGl.canvas.getContext(\"webgl\", {\n                    antialias: true\n                }), _miniGl.meshes = [];\n                const context = _miniGl.gl;\n                width && height && this.setSize(width, height), _miniGl.lastDebugMsg, _miniGl.debug = debug && debug_output ? function(e) {\n                    const t = new Date();\n                    t - _miniGl.lastDebugMsg > 1e3 && console.log(\"---\"), console.log(t.toLocaleTimeString() + Array(Math.max(0, 32 - e.length)).join(\" \") + e + \": \", ...Array.from(arguments).slice(1)), _miniGl.lastDebugMsg = t;\n                } : ()=>{}, Object.defineProperties(_miniGl, {\n                    Material: {\n                        enumerable: false,\n                        value: class {\n                            //t = uniform\n                            attachUniforms(name, uniforms) {\n                                //n  = material\n                                const material = this;\n                                void 0 === name ? Object.entries(uniforms).forEach((param)=>{\n                                    let [name, uniform] = param;\n                                    material.attachUniforms(name, uniform);\n                                }) : \"array\" == uniforms.type ? uniforms.value.forEach((uniform, i)=>material.attachUniforms(\"\".concat(name, \"[\").concat(i, \"]\"), uniform)) : \"struct\" == uniforms.type ? Object.entries(uniforms.value).forEach((param)=>{\n                                    let [uniform, i] = param;\n                                    return material.attachUniforms(\"\".concat(name, \".\").concat(uniform), i);\n                                }) : (_miniGl.debug(\"Material.attachUniforms\", {\n                                    name: name,\n                                    uniform: uniforms\n                                }), material.uniformInstances.push({\n                                    uniform: uniforms,\n                                    location: context.getUniformLocation(material.program, name)\n                                }));\n                            }\n                            constructor(vertexShaders, fragments, uniforms = {}){\n                                const material = this;\n                                function getShaderByType(type, source) {\n                                    const shader = context.createShader(type);\n                                    return context.shaderSource(shader, source), context.compileShader(shader), context.getShaderParameter(shader, context.COMPILE_STATUS) || console.error(context.getShaderInfoLog(shader)), _miniGl.debug(\"Material.compileShaderSource\", {\n                                        source: source\n                                    }), shader;\n                                }\n                                function getUniformVariableDeclarations(uniforms, type) {\n                                    return Object.entries(uniforms).map((param)=>{\n                                        let [uniform, value] = param;\n                                        return value.getDeclaration(uniform, type);\n                                    }).join(\"\\n\");\n                                }\n                                material.uniforms = uniforms, material.uniformInstances = [];\n                                const prefix = \"\\n              precision highp float;\\n            \";\n                                material.vertexSource = \"\\n              \".concat(prefix, \"\\n              attribute vec4 position;\\n              attribute vec2 uv;\\n              attribute vec2 uvNorm;\\n              \").concat(getUniformVariableDeclarations(_miniGl.commonUniforms, \"vertex\"), \"\\n              \").concat(getUniformVariableDeclarations(uniforms, \"vertex\"), \"\\n              \").concat(vertexShaders, \"\\n            \"), material.Source = \"\\n              \".concat(prefix, \"\\n              \").concat(getUniformVariableDeclarations(_miniGl.commonUniforms, \"fragment\"), \"\\n              \").concat(getUniformVariableDeclarations(uniforms, \"fragment\"), \"\\n              \").concat(fragments, \"\\n            \"), material.vertexShader = getShaderByType(context.VERTEX_SHADER, material.vertexSource), material.fragmentShader = getShaderByType(context.FRAGMENT_SHADER, material.Source), material.program = context.createProgram(), context.attachShader(material.program, material.vertexShader), context.attachShader(material.program, material.fragmentShader), context.linkProgram(material.program), context.getProgramParameter(material.program, context.LINK_STATUS) || console.error(context.getProgramInfoLog(material.program)), context.useProgram(material.program), material.attachUniforms(void 0, _miniGl.commonUniforms), material.attachUniforms(void 0, material.uniforms);\n                            }\n                        }\n                    },\n                    Uniform: {\n                        enumerable: !1,\n                        value: class {\n                            update(value) {\n                                void 0 !== this.value && context[\"uniform\".concat(this.typeFn)](value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.transpose : this.value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.value : null);\n                            }\n                            //e - name\n                            //t - type\n                            //n - length\n                            getDeclaration(name, type, length) {\n                                const uniform = this;\n                                if (uniform.excludeFrom !== type) {\n                                    if (\"array\" === uniform.type) return uniform.value[0].getDeclaration(name, type, uniform.value.length) + \"\\nconst int \".concat(name, \"_length = \").concat(uniform.value.length, \";\");\n                                    if (\"struct\" === uniform.type) {\n                                        let name_no_prefix = name.replace(\"u_\", \"\");\n                                        return name_no_prefix = name_no_prefix.charAt(0).toUpperCase() + name_no_prefix.slice(1), \"uniform struct \".concat(name_no_prefix, \" \\n                                  {\\n\") + Object.entries(uniform.value).map((param)=>{\n                                            let [name, uniform] = param;\n                                            return uniform.getDeclaration(name, type).replace(/^uniform/, \"\");\n                                        }).join(\"\") + \"\\n} \".concat(name).concat(length > 0 ? \"[\".concat(length, \"]\") : \"\", \";\");\n                                    }\n                                    return \"uniform \".concat(uniform.type, \" \").concat(name).concat(length > 0 ? \"[\".concat(length, \"]\") : \"\", \";\");\n                                }\n                            }\n                            constructor(e){\n                                this.type = \"float\", Object.assign(this, e);\n                                this.typeFn = ({\n                                    float: \"1f\",\n                                    int: \"1i\",\n                                    vec2: \"2fv\",\n                                    vec3: \"3fv\",\n                                    vec4: \"4fv\",\n                                    mat4: \"Matrix4fv\"\n                                })[this.type] || \"1f\", this.update();\n                            }\n                        }\n                    },\n                    PlaneGeometry: {\n                        enumerable: !1,\n                        value: class {\n                            setTopology() {\n                                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n                                const n = this;\n                                n.xSegCount = e, n.ySegCount = t, n.vertexCount = (n.xSegCount + 1) * (n.ySegCount + 1), n.quadCount = n.xSegCount * n.ySegCount * 2, n.attributes.uv.values = new Float32Array(2 * n.vertexCount), n.attributes.uvNorm.values = new Float32Array(2 * n.vertexCount), n.attributes.index.values = new Uint16Array(3 * n.quadCount);\n                                for(let e = 0; e <= n.ySegCount; e++)for(let t = 0; t <= n.xSegCount; t++){\n                                    const i = e * (n.xSegCount + 1) + t;\n                                    if (n.attributes.uv.values[2 * i] = t / n.xSegCount, n.attributes.uv.values[2 * i + 1] = 1 - e / n.ySegCount, n.attributes.uvNorm.values[2 * i] = t / n.xSegCount * 2 - 1, n.attributes.uvNorm.values[2 * i + 1] = 1 - e / n.ySegCount * 2, t < n.xSegCount && e < n.ySegCount) {\n                                        const s = e * n.xSegCount + t;\n                                        n.attributes.index.values[6 * s] = i, n.attributes.index.values[6 * s + 1] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 2] = i + 1, n.attributes.index.values[6 * s + 3] = i + 1, n.attributes.index.values[6 * s + 4] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 5] = i + 2 + n.xSegCount;\n                                    }\n                                }\n                                n.attributes.uv.update(), n.attributes.uvNorm.update(), n.attributes.index.update(), _miniGl.debug(\"Geometry.setTopology\", {\n                                    uv: n.attributes.uv,\n                                    uvNorm: n.attributes.uvNorm,\n                                    index: n.attributes.index\n                                });\n                            }\n                            setSize() {\n                                let width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, orientation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"xz\";\n                                const geometry = this;\n                                geometry.width = width, geometry.height = height, geometry.orientation = orientation, geometry.attributes.position.values && geometry.attributes.position.values.length === 3 * geometry.vertexCount || (geometry.attributes.position.values = new Float32Array(3 * geometry.vertexCount));\n                                const o = width / -2, r = height / -2, segment_width = width / geometry.xSegCount, segment_height = height / geometry.ySegCount;\n                                for(let yIndex = 0; yIndex <= geometry.ySegCount; yIndex++){\n                                    const t = r + yIndex * segment_height;\n                                    for(let xIndex = 0; xIndex <= geometry.xSegCount; xIndex++){\n                                        const r = o + xIndex * segment_width, l = yIndex * (geometry.xSegCount + 1) + xIndex;\n                                        geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[0])] = r, geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[1])] = -t;\n                                    }\n                                }\n                                geometry.attributes.position.update(), _miniGl.debug(\"Geometry.setSize\", {\n                                    position: geometry.attributes.position\n                                });\n                            }\n                            constructor(width, height, n, i, orientation){\n                                context.createBuffer(), this.attributes = {\n                                    position: new _miniGl.Attribute({\n                                        target: context.ARRAY_BUFFER,\n                                        size: 3\n                                    }),\n                                    uv: new _miniGl.Attribute({\n                                        target: context.ARRAY_BUFFER,\n                                        size: 2\n                                    }),\n                                    uvNorm: new _miniGl.Attribute({\n                                        target: context.ARRAY_BUFFER,\n                                        size: 2\n                                    }),\n                                    index: new _miniGl.Attribute({\n                                        target: context.ELEMENT_ARRAY_BUFFER,\n                                        size: 3,\n                                        type: context.UNSIGNED_SHORT\n                                    })\n                                }, this.setTopology(n, i), this.setSize(width, height, orientation);\n                            }\n                        }\n                    },\n                    Mesh: {\n                        enumerable: !1,\n                        value: class {\n                            draw() {\n                                context.useProgram(this.material.program), this.material.uniformInstances.forEach((param)=>{\n                                    let { uniform: e, location: t } = param;\n                                    return e.update(t);\n                                }), this.attributeInstances.forEach((param)=>{\n                                    let { attribute: e, location: t } = param;\n                                    return e.use(t);\n                                }), context.drawElements(this.wireframe ? context.LINES : context.TRIANGLES, this.geometry.attributes.index.values.length, context.UNSIGNED_SHORT, 0);\n                            }\n                            remove() {\n                                _miniGl.meshes = _miniGl.meshes.filter((e)=>e != this);\n                            }\n                            constructor(geometry, material){\n                                const mesh = this;\n                                mesh.geometry = geometry, mesh.material = material, mesh.wireframe = !1, mesh.attributeInstances = [], Object.entries(mesh.geometry.attributes).forEach((param)=>{\n                                    let [e, attribute] = param;\n                                    mesh.attributeInstances.push({\n                                        attribute: attribute,\n                                        location: attribute.attach(e, mesh.material.program)\n                                    });\n                                }), _miniGl.meshes.push(mesh), _miniGl.debug(\"Mesh.constructor\", {\n                                    mesh: mesh\n                                });\n                            }\n                        }\n                    },\n                    Attribute: {\n                        enumerable: !1,\n                        value: class {\n                            update() {\n                                void 0 !== this.values && (context.bindBuffer(this.target, this.buffer), context.bufferData(this.target, this.values, context.STATIC_DRAW));\n                            }\n                            attach(e, t) {\n                                const n = context.getAttribLocation(t, e);\n                                return this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(n), context.vertexAttribPointer(n, this.size, this.type, this.normalized, 0, 0)), n;\n                            }\n                            use(e) {\n                                context.bindBuffer(this.target, this.buffer), this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(e), context.vertexAttribPointer(e, this.size, this.type, this.normalized, 0, 0));\n                            }\n                            constructor(e){\n                                this.type = context.FLOAT, this.normalized = !1, this.buffer = context.createBuffer(), Object.assign(this, e), this.update();\n                            }\n                        }\n                    }\n                });\n                const a = [\n                    1,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n                _miniGl.commonUniforms = {\n                    projectionMatrix: new _miniGl.Uniform({\n                        type: \"mat4\",\n                        value: a\n                    }),\n                    modelViewMatrix: new _miniGl.Uniform({\n                        type: \"mat4\",\n                        value: a\n                    }),\n                    resolution: new _miniGl.Uniform({\n                        type: \"vec2\",\n                        value: [\n                            1,\n                            1\n                        ]\n                    }),\n                    aspectRatio: new _miniGl.Uniform({\n                        type: \"float\",\n                        value: 1\n                    })\n                };\n            }\n        }\n        //Sets initial properties\n        function e(object, propertyName, val) {\n            return propertyName in object ? Object.defineProperty(object, propertyName, {\n                value: val,\n                enumerable: !0,\n                configurable: !0,\n                writable: !0\n            }) : object[propertyName] = val, object;\n        }\n        //Gradient object\n        class Gradient {\n            async connect() {\n                this.shaderFiles = {\n                    vertex: \"varying vec3 v_color;\\n\\nvoid main() {\\n  float time = u_time * u_global.noiseSpeed;\\n\\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\\n\\n  vec2 st = 1. - uvNorm.xy;\\n\\n  //\\n  // Tilting the plane\\n  //\\n\\n  // Front-to-back tilt\\n  float tilt = resolution.y / 2.0 * uvNorm.y;\\n\\n  // Left-to-right angle\\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\\n\\n  // Up-down shift to offset incline\\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\\n\\n  //\\n  // Vertex noise\\n  //\\n\\n  float noise = snoise(vec3(\\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\\n  )) * u_vertDeform.noiseAmp;\\n\\n  // Fade noise to zero at edges\\n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\\n\\n  // Clamp to 0\\n  noise = max(0.0, noise);\\n\\n  vec3 pos = vec3(\\n    position.x,\\n    position.y + tilt + incline + noise - offset,\\n    position.z\\n  );\\n\\n  //\\n  // Vertex color, to be passed to fragment shader\\n  //\\n\\n  if (u_active_colors[0] == 1.) {\\n    v_color = u_baseColor;\\n  }\\n\\n  for (int i = 0; i < u_waveLayers_length; i++) {\\n    if (u_active_colors[i + 1] == 1.) {\\n      WaveLayers layer = u_waveLayers[i];\\n\\n      float noise = smoothstep(\\n        layer.noiseFloor,\\n        layer.noiseCeil,\\n        snoise(vec3(\\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\\n          noiseCoord.y * layer.noiseFreq.y,\\n          time * layer.noiseSpeed + layer.noiseSeed\\n        )) / 2.0 + 0.5\\n      );\\n\\n      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));\\n    }\\n  }\\n\\n  //\\n  // Finish\\n  //\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n}\",\n                    noise: \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\",\n                    blend: \"//\\n// https://github.com/jamieowen/glsl-blend\\n//\\n\\n// Normal\\n\\nvec3 blendNormal(vec3 base, vec3 blend) {\\n\treturn blend;\\n}\\n\\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Screen\\n\\nfloat blendScreen(float base, float blend) {\\n\treturn 1.0-((1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend) {\\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Multiply\\n\\nvec3 blendMultiply(vec3 base, vec3 blend) {\\n\treturn base*blend;\\n}\\n\\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Overlay\\n\\nfloat blendOverlay(float base, float blend) {\\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend) {\\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Hard light\\n\\nvec3 blendHardLight(vec3 base, vec3 blend) {\\n\treturn blendOverlay(blend,base);\\n}\\n\\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Soft light\\n\\nfloat blendSoftLight(float base, float blend) {\\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend) {\\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color dodge\\n\\nfloat blendColorDodge(float base, float blend) {\\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend) {\\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color burn\\n\\nfloat blendColorBurn(float base, float blend) {\\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend) {\\n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Vivid Light\\n\\nfloat blendVividLight(float base, float blend) {\\n\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend) {\\n\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Lighten\\n\\nfloat blendLighten(float base, float blend) {\\n\treturn max(blend,base);\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend) {\\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear burn\\n\\nfloat blendLinearBurn(float base, float blend) {\\n\t// Note : Same implementation as BlendSubtractf\\n\treturn max(base+blend-1.0,0.0);\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\\n\t// Note : Same implementation as BlendSubtract\\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear dodge\\n\\nfloat blendLinearDodge(float base, float blend) {\\n\t// Note : Same implementation as BlendAddf\\n\treturn min(base+blend,1.0);\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\\n\t// Note : Same implementation as BlendAdd\\n\treturn min(base+blend,vec3(1.0));\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear light\\n\\nfloat blendLinearLight(float base, float blend) {\\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend) {\\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\",\n                    fragment: \"varying vec3 v_color;\\n\\nvoid main() {\\n  vec3 color = v_color;\\n  if (u_darken_top == 1.0) {\\n    vec2 st = gl_FragCoord.xy/resolution.xy;\\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\\n  }\\n  gl_FragColor = vec4(color, 1.0);\\n}\"\n                }, this.conf = {\n                    presetName: \"\",\n                    wireframe: false,\n                    density: [\n                        0.06,\n                        0.16\n                    ],\n                    zoom: 1,\n                    rotation: 0,\n                    playing: true\n                }, document.querySelectorAll(\"canvas\").length < 1 ? console.log(\"DID NOT LOAD HERO STRIPE CANVAS\") : (this.minigl = new MiniGl(this.el, null, null, !0), requestAnimationFrame(()=>{\n                    this.el && (this.computedCanvasStyle = getComputedStyle(this.el), this.waitForCssVars());\n                }));\n            /*\n          this.scrollObserver = await s.create(.1, !1),\n          this.scrollObserver.observe(this.el),\n          this.scrollObserver.onSeparate(() => {\n              window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !1, this.conf.playing && this.pause()\n          }), \n          this.scrollObserver.onIntersect(() => {\n              window.addEventListener(\"scroll\", this.handleScroll), window.addEventListener(\"mousedown\", this.handleMouseDown), window.addEventListener(\"mouseup\", this.handleMouseUp), window.addEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !0, this.addIsLoadedClass(), this.play()\n          })*/ }\n            disconnect() {\n                this.scrollObserver && (window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.scrollObserver.disconnect()), window.removeEventListener(\"resize\", this.resize);\n            }\n            initMaterial() {\n                this.uniforms = {\n                    u_time: new this.minigl.Uniform({\n                        value: 0\n                    }),\n                    u_shadow_power: new this.minigl.Uniform({\n                        value: 10\n                    }),\n                    u_darken_top: new this.minigl.Uniform({\n                        value: \"\" === this.el.dataset.jsDarkenTop ? 1 : 0\n                    }),\n                    u_active_colors: new this.minigl.Uniform({\n                        value: this.activeColors,\n                        type: \"vec4\"\n                    }),\n                    u_global: new this.minigl.Uniform({\n                        value: {\n                            noiseFreq: new this.minigl.Uniform({\n                                value: [\n                                    this.freqX,\n                                    this.freqY\n                                ],\n                                type: \"vec2\"\n                            }),\n                            noiseSpeed: new this.minigl.Uniform({\n                                value: 5e-6\n                            })\n                        },\n                        type: \"struct\"\n                    }),\n                    u_vertDeform: new this.minigl.Uniform({\n                        value: {\n                            incline: new this.minigl.Uniform({\n                                value: Math.sin(this.angle) / Math.cos(this.angle)\n                            }),\n                            offsetTop: new this.minigl.Uniform({\n                                value: -0.5\n                            }),\n                            offsetBottom: new this.minigl.Uniform({\n                                value: -0.5\n                            }),\n                            noiseFreq: new this.minigl.Uniform({\n                                value: [\n                                    3,\n                                    4\n                                ],\n                                type: \"vec2\"\n                            }),\n                            noiseAmp: new this.minigl.Uniform({\n                                value: this.amp\n                            }),\n                            noiseSpeed: new this.minigl.Uniform({\n                                value: 10\n                            }),\n                            noiseFlow: new this.minigl.Uniform({\n                                value: 3\n                            }),\n                            noiseSeed: new this.minigl.Uniform({\n                                value: this.seed\n                            })\n                        },\n                        type: \"struct\",\n                        excludeFrom: \"fragment\"\n                    }),\n                    u_baseColor: new this.minigl.Uniform({\n                        value: this.sectionColors[0],\n                        type: \"vec3\",\n                        excludeFrom: \"fragment\"\n                    }),\n                    u_waveLayers: new this.minigl.Uniform({\n                        value: [],\n                        excludeFrom: \"fragment\",\n                        type: \"array\"\n                    })\n                };\n                for(let e = 1; e < this.sectionColors.length; e += 1)this.uniforms.u_waveLayers.value.push(new this.minigl.Uniform({\n                    value: {\n                        color: new this.minigl.Uniform({\n                            value: this.sectionColors[e],\n                            type: \"vec3\"\n                        }),\n                        noiseFreq: new this.minigl.Uniform({\n                            value: [\n                                2 + e / this.sectionColors.length,\n                                3 + e / this.sectionColors.length\n                            ],\n                            type: \"vec2\"\n                        }),\n                        noiseSpeed: new this.minigl.Uniform({\n                            value: 11 + 0.3 * e\n                        }),\n                        noiseFlow: new this.minigl.Uniform({\n                            value: 6.5 + 0.3 * e\n                        }),\n                        noiseSeed: new this.minigl.Uniform({\n                            value: this.seed + 10 * e\n                        }),\n                        noiseFloor: new this.minigl.Uniform({\n                            value: 0.1\n                        }),\n                        noiseCeil: new this.minigl.Uniform({\n                            value: 0.63 + 0.07 * e\n                        })\n                    },\n                    type: \"struct\"\n                }));\n                return this.vertexShader = [\n                    this.shaderFiles.noise,\n                    this.shaderFiles.blend,\n                    this.shaderFiles.vertex\n                ].join(\"\\n\\n\"), new this.minigl.Material(this.vertexShader, this.shaderFiles.fragment, this.uniforms);\n            }\n            initMesh() {\n                this.material = this.initMaterial(), this.geometry = new this.minigl.PlaneGeometry(), this.mesh = new this.minigl.Mesh(this.geometry, this.material);\n            }\n            shouldSkipFrame(e) {\n                return !!window.document.hidden || !this.conf.playing || parseInt(e, 10) % 2 == 0 || void 0;\n            }\n            updateFrequency(e) {\n                this.freqX += e, this.freqY += e;\n            }\n            toggleColor(index) {\n                this.activeColors[index] = 0 === this.activeColors[index] ? 1 : 0;\n            }\n            showGradientLegend() {\n                this.width > this.minWidth && (this.isGradientLegendVisible = !0, document.body.classList.add(\"isGradientLegendVisible\"));\n            }\n            hideGradientLegend() {\n                this.isGradientLegendVisible = !1, document.body.classList.remove(\"isGradientLegendVisible\");\n            }\n            init() {\n                this.initGradientColors(), this.initMesh(), this.resize(), requestAnimationFrame(this.animate), window.addEventListener(\"resize\", this.resize);\n            }\n            /*\n       * Waiting for the css variables to become available, usually on page load before we can continue.\n       * Using default colors assigned below if no variables have been found after maxCssVarRetries\n       */ waitForCssVars() {\n                if (this.computedCanvasStyle && -1 !== this.computedCanvasStyle.getPropertyValue(\"--gradient-color-1\").indexOf(\"#\")) this.init(), this.addIsLoadedClass();\n                else {\n                    if (this.cssVarRetries += 1, this.cssVarRetries > this.maxCssVarRetries) {\n                        return this.sectionColors = [\n                            16711680,\n                            16711680,\n                            16711935,\n                            65280,\n                            255\n                        ], void this.init();\n                    }\n                    requestAnimationFrame(()=>this.waitForCssVars());\n                }\n            }\n            /*\n       * Initializes the four section colors by retrieving them from css variables.\n       */ initGradientColors() {\n                this.sectionColors = [\n                    \"--gradient-color-1\",\n                    \"--gradient-color-2\",\n                    \"--gradient-color-3\",\n                    \"--gradient-color-4\"\n                ].map((cssPropertyName)=>{\n                    let hex = this.computedCanvasStyle.getPropertyValue(cssPropertyName).trim();\n                    //Check if shorthand hex value was used and double the length so the conversion in normalizeColor will work.\n                    if (4 === hex.length) {\n                        const hexTemp = hex.substr(1).split(\"\").map((hexTemp)=>hexTemp + hexTemp).join(\"\");\n                        hex = \"#\".concat(hexTemp);\n                    }\n                    return hex && \"0x\".concat(hex.substr(1));\n                }).filter(Boolean).map(normalizeColor);\n            }\n            constructor(...t){\n                e(this, \"el\", void 0), e(this, \"cssVarRetries\", 0), e(this, \"maxCssVarRetries\", 200), e(this, \"angle\", 0), e(this, \"isLoadedClass\", !1), e(this, \"isScrolling\", !1), /*e(this, \"isStatic\", o.disableAmbientAnimations()),*/ e(this, \"scrollingTimeout\", void 0), e(this, \"scrollingRefreshDelay\", 200), e(this, \"isIntersecting\", !1), e(this, \"shaderFiles\", void 0), e(this, \"vertexShader\", void 0), e(this, \"sectionColors\", void 0), e(this, \"computedCanvasStyle\", void 0), e(this, \"conf\", void 0), e(this, \"uniforms\", void 0), e(this, \"t\", 1253106), e(this, \"last\", 0), e(this, \"width\", void 0), e(this, \"minWidth\", 1111), e(this, \"height\", 600), e(this, \"xSegCount\", void 0), e(this, \"ySegCount\", void 0), e(this, \"mesh\", void 0), e(this, \"material\", void 0), e(this, \"geometry\", void 0), e(this, \"minigl\", void 0), e(this, \"scrollObserver\", void 0), e(this, \"amp\", 320), e(this, \"seed\", 5), e(this, \"freqX\", 14e-5), e(this, \"freqY\", 29e-5), e(this, \"freqDelta\", 1e-5), e(this, \"activeColors\", [\n                    1,\n                    1,\n                    1,\n                    1\n                ]), e(this, \"isMetaKey\", !1), e(this, \"isGradientLegendVisible\", !1), e(this, \"isMouseDown\", !1), e(this, \"handleScroll\", ()=>{\n                    clearTimeout(this.scrollingTimeout), this.scrollingTimeout = setTimeout(this.handleScrollEnd, this.scrollingRefreshDelay), this.isGradientLegendVisible && this.hideGradientLegend(), this.conf.playing && (this.isScrolling = !0, this.pause());\n                }), e(this, \"handleScrollEnd\", ()=>{\n                    this.isScrolling = !1, this.isIntersecting && this.play();\n                }), e(this, \"resize\", ()=>{\n                    this.width = window.innerWidth, this.minigl.setSize(this.width, this.height), this.minigl.setOrthographicCamera(), this.xSegCount = Math.ceil(this.width * this.conf.density[0]), this.ySegCount = Math.ceil(this.height * this.conf.density[1]), this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount), this.mesh.geometry.setSize(this.width, this.height), this.mesh.material.uniforms.u_shadow_power.value = this.width < 600 ? 5 : 6;\n                }), e(this, \"handleMouseDown\", (e)=>{\n                    this.isGradientLegendVisible && (this.isMetaKey = e.metaKey, this.isMouseDown = !0, !1 === this.conf.playing && requestAnimationFrame(this.animate));\n                }), e(this, \"handleMouseUp\", ()=>{\n                    this.isMouseDown = !1;\n                }), e(this, \"animate\", (e)=>{\n                    if (!this.shouldSkipFrame(e) || this.isMouseDown) {\n                        if (this.t += Math.min(e - this.last, 1e3 / 15), this.last = e, this.isMouseDown) {\n                            let e = 160;\n                            this.isMetaKey && (e = -160), this.t += e;\n                        }\n                        this.mesh.material.uniforms.u_time.value = this.t, this.minigl.render();\n                    }\n                    if (0 !== this.last && this.isStatic) return this.minigl.render(), void this.disconnect();\n                    /*this.isIntersecting && */ (this.conf.playing || this.isMouseDown) && requestAnimationFrame(this.animate);\n                }), e(this, \"addIsLoadedClass\", ()=>{\n                    /*this.isIntersecting && */ !this.isLoadedClass && (this.isLoadedClass = !0, this.el.classList.add(\"isLoaded\"), setTimeout(()=>{\n                        this.el.parentElement.classList.add(\"isLoaded\");\n                    }, 3e3));\n                }), e(this, \"pause\", ()=>{\n                    this.conf.playing = false;\n                }), e(this, \"play\", ()=>{\n                    requestAnimationFrame(this.animate), this.conf.playing = true;\n                }), e(this, \"initGradient\", (selector)=>{\n                    this.el = document.querySelector(selector);\n                    this.connect();\n                    return this;\n                });\n            }\n        }\n        /*\n     *Finally initializing the Gradient class, assigning a canvas to it and calling Gradient.connect() which initializes everything,\n     * Use Gradient.pause() and Gradient.play() for controls.\n     *\n     * Here are some default property values you can change anytime:\n     * Amplitude:    Gradient.amp = 0\n     * Colors:       Gradient.sectionColors (if you change colors, use normalizeColor(#hexValue)) before you assign it.\n     *\n     *\n     * Useful functions\n     * Gradient.toggleColor(index)\n     * Gradient.updateFrequency(freq)\n     */ var gradient = new Gradient();\n        gradient.initGradient(\"#gradient-canvas\");\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            id: \"gradient-canvas\",\n            style: \"width:100vw;height:100vh\"\n        }, void 0, false, {\n            fileName: \"/Users/admin/repos/SURVISION-landing-page/app/Stripe.js\",\n            lineNumber: 906,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/admin/repos/SURVISION-landing-page/app/Stripe.js\",\n        lineNumber: 905,\n        columnNumber: 5\n    }, this);\n}\n_s(Stripe, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = Stripe;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Stripe);\nvar _c;\n$RefreshReg$(_c, \"Stripe\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxhQUN0Qm1CLFdBQVc7d0JBQ1QsSUFBSSxDQUFDM0UsRUFBRSxDQUFDMkYsYUFBYSxDQUFDcEMsU0FBUyxDQUFDQyxHQUFHLENBQUM7b0JBQ3RDLEdBQUcsSUFBRztnQkFDVixJQUNBek8sRUFBRSxJQUFJLEVBQUUsU0FBUztvQkFDZixJQUFJLENBQUN5SyxJQUFJLENBQUNLLE9BQU8sR0FBRztnQkFDdEIsSUFDQTlLLEVBQUUsSUFBSSxFQUFFLFFBQVE7b0JBQ2RrTCxzQkFBc0IsSUFBSSxDQUFDMkQsT0FBTyxHQUFJLElBQUksQ0FBQ3BFLElBQUksQ0FBQ0ssT0FBTyxHQUFHO2dCQUM1RCxJQUNBOUssRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLENBQUM2UTtvQkFDdkIsSUFBSSxDQUFDNUYsRUFBRSxHQUFHekosU0FBU3NQLGFBQWEsQ0FBQ0Q7b0JBQ2pDLElBQUksQ0FBQzFHLE9BQU87b0JBQ1osT0FBTyxJQUFJO2dCQUNiO1lBQ0o7UUE0UEY7UUFFQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDRCxJQUFJNEcsV0FBVyxJQUFJN0c7UUFDbkI2RyxTQUFTQyxZQUFZLENBQUM7SUFDeEIsR0FBRyxFQUFFO0lBRUwscUJBQ0UsOERBQUNDO2tCQUNDLDRFQUFDOVE7WUFBTytRLElBQUc7WUFBa0JDLE9BQU07Ozs7Ozs7Ozs7O0FBR3pDO0dBejRCUzdSO0tBQUFBO0FBMjRCVCwrREFBZUEsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvU3RyaXBlLmpzPzFhNTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcblxuZnVuY3Rpb24gU3RyaXBlKCkge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8qXG4gICAgICogICBTdHJpcGUgV2ViR2wgR3JhZGllbnQgQW5pbWF0aW9uIGJ5IFN0cmlwZS5jb21cbiAgICAgKiAgIFNjcm9sbE9ic2VydmVyIGZ1bmN0aW9uYWxpdHkgdG8gZGlzYWJsZSBhbmltYXRpb24gd2hlbiBub3Qgc2Nyb2xsZWQgaW50byB2aWV3IGhhcyBiZWVuIGRpc2FibGVkIGFuZFxuICAgICAqICAgY29tbWVudGVkIG91dCBmb3Igbm93LlxuICAgICAqL1xuXG4gICAgLy9Db252ZXJ0aW5nIGNvbG9ycyB0byBwcm9wZXIgZm9ybWF0XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplQ29sb3IoaGV4Q29kZSkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgKChoZXhDb2RlID4+IDE2KSAmIDI1NSkgLyAyNTUsXG4gICAgICAgICgoaGV4Q29kZSA+PiA4KSAmIDI1NSkgLyAyNTUsXG4gICAgICAgICgyNTUgJiBoZXhDb2RlKSAvIDI1NSxcbiAgICAgIF07XG4gICAgfVxuICAgIFtcIlNDUkVFTlwiLCBcIkxJTkVBUl9MSUdIVFwiXS5yZWR1Y2UoXG4gICAgICAoaGV4Q29kZSwgdCwgbikgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihoZXhDb2RlLCB7XG4gICAgICAgICAgW3RdOiBuLFxuICAgICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcblxuICAgIC8vRXNzZW50aWFsIGZ1bmN0aW9uYWxpdHkgb2YgV2ViR2xcbiAgICAvL3QgPSB3aWR0aFxuICAgIC8vbiA9IGhlaWdodFxuICAgIGNsYXNzIE1pbmlHbCB7XG4gICAgICBjb25zdHJ1Y3RvcihjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGRlYnVnID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgX21pbmlHbCA9IHRoaXMsXG4gICAgICAgICAgZGVidWdfb3V0cHV0ID1cbiAgICAgICAgICAgIC0xICE9PVxuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImRlYnVnPXdlYmdsXCIpO1xuICAgICAgICAoX21pbmlHbC5jYW52YXMgPSBjYW52YXMpLFxuICAgICAgICAgIChfbWluaUdsLmdsID0gX21pbmlHbC5jYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIHtcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgICAgICB9KSksXG4gICAgICAgICAgKF9taW5pR2wubWVzaGVzID0gW10pO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gX21pbmlHbC5nbDtcbiAgICAgICAgd2lkdGggJiYgaGVpZ2h0ICYmIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSxcbiAgICAgICAgICBfbWluaUdsLmxhc3REZWJ1Z01zZyxcbiAgICAgICAgICAoX21pbmlHbC5kZWJ1ZyA9XG4gICAgICAgICAgICBkZWJ1ZyAmJiBkZWJ1Z19vdXRwdXRcbiAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICB0IC0gX21pbmlHbC5sYXN0RGVidWdNc2cgPiAxZTMgJiYgY29uc29sZS5sb2coXCItLS1cIiksXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAgIHQudG9Mb2NhbGVUaW1lU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkoTWF0aC5tYXgoMCwgMzIgLSBlLmxlbmd0aCkpLmpvaW4oXCIgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCI6IFwiLFxuICAgICAgICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20oYXJndW1lbnRzKS5zbGljZSgxKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAoX21pbmlHbC5sYXN0RGVidWdNc2cgPSB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDogKCkgPT4ge30pLFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF9taW5pR2wsIHtcbiAgICAgICAgICAgIE1hdGVyaWFsOiB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogY2xhc3Mge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZlcnRleFNoYWRlcnMsIGZyYWdtZW50cywgdW5pZm9ybXMgPSB7fSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2hhZGVyQnlUeXBlKHR5cGUsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFkZXIgPSBjb250ZXh0LmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSksXG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jb21waWxlU2hhZGVyKHNoYWRlciksXG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nZXRTaGFkZXJQYXJhbWV0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LkNPTVBJTEVfU1RBVFVTXG4gICAgICAgICAgICAgICAgICAgICAgKSB8fCBjb25zb2xlLmVycm9yKGNvbnRleHQuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgICBfbWluaUdsLmRlYnVnKFwiTWF0ZXJpYWwuY29tcGlsZVNoYWRlclNvdXJjZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBzaGFkZXJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFVuaWZvcm1WYXJpYWJsZURlY2xhcmF0aW9ucyh1bmlmb3JtcywgdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModW5pZm9ybXMpXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcCgoW3VuaWZvcm0sIHZhbHVlXSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmdldERlY2xhcmF0aW9uKHVuaWZvcm0sIHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKG1hdGVyaWFsLnVuaWZvcm1zID0gdW5pZm9ybXMpLFxuICAgICAgICAgICAgICAgICAgICAobWF0ZXJpYWwudW5pZm9ybUluc3RhbmNlcyA9IFtdKTtcblxuICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID1cbiAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgICAgICAgICBcIjtcbiAgICAgICAgICAgICAgICAgIChtYXRlcmlhbC52ZXJ0ZXhTb3VyY2UgPSBgXFxuICAgICAgICAgICAgICAke3ByZWZpeH1cXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uO1xcbiAgICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgdXY7XFxuICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiB1dk5vcm07XFxuICAgICAgICAgICAgICAke2dldFVuaWZvcm1WYXJpYWJsZURlY2xhcmF0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgX21pbmlHbC5jb21tb25Vbmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgXCJ2ZXJ0ZXhcIlxuICAgICAgICAgICAgICAgICAgKX1cXG4gICAgICAgICAgICAgICR7Z2V0VW5pZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25zKFxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgXCJ2ZXJ0ZXhcIlxuICAgICAgICAgICAgICAgICAgKX1cXG4gICAgICAgICAgICAgICR7dmVydGV4U2hhZGVyc31cXG4gICAgICAgICAgICBgKSxcbiAgICAgICAgICAgICAgICAgICAgKG1hdGVyaWFsLlNvdXJjZSA9IGBcXG4gICAgICAgICAgICAgICR7cHJlZml4fVxcbiAgICAgICAgICAgICAgJHtnZXRVbmlmb3JtVmFyaWFibGVEZWNsYXJhdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgICAgX21pbmlHbC5jb21tb25Vbmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgICBcImZyYWdtZW50XCJcbiAgICAgICAgICAgICAgICAgICAgKX1cXG4gICAgICAgICAgICAgICR7Z2V0VW5pZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZnJhZ21lbnRcIlxuICAgICAgICAgICAgICAgICAgICApfVxcbiAgICAgICAgICAgICAgJHtmcmFnbWVudHN9XFxuICAgICAgICAgICAgYCksXG4gICAgICAgICAgICAgICAgICAgIChtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBnZXRTaGFkZXJCeVR5cGUoXG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5WRVJURVhfU0hBREVSLFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLnZlcnRleFNvdXJjZVxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0gZ2V0U2hhZGVyQnlUeXBlKFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuRlJBR01FTlRfU0hBREVSLFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLlNvdXJjZVxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKG1hdGVyaWFsLnByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0oKSksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXR0YWNoU2hhZGVyKFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLnByb2dyYW0sXG4gICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwudmVydGV4U2hhZGVyXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXR0YWNoU2hhZGVyKFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLnByb2dyYW0sXG4gICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXJcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5rUHJvZ3JhbShtYXRlcmlhbC5wcm9ncmFtKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nZXRQcm9ncmFtUGFyYW1ldGVyKFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLnByb2dyYW0sXG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5MSU5LX1NUQVRVU1xuICAgICAgICAgICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZ2V0UHJvZ3JhbUluZm9Mb2cobWF0ZXJpYWwucHJvZ3JhbSlcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnVzZVByb2dyYW0obWF0ZXJpYWwucHJvZ3JhbSksXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLmF0dGFjaFVuaWZvcm1zKHZvaWQgMCwgX21pbmlHbC5jb21tb25Vbmlmb3JtcyksXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLmF0dGFjaFVuaWZvcm1zKHZvaWQgMCwgbWF0ZXJpYWwudW5pZm9ybXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL3QgPSB1bmlmb3JtXG4gICAgICAgICAgICAgICAgYXR0YWNoVW5pZm9ybXMobmFtZSwgdW5pZm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgIC8vbiAgPSBtYXRlcmlhbFxuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBuYW1lXG4gICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmVudHJpZXModW5pZm9ybXMpLmZvckVhY2goKFtuYW1lLCB1bmlmb3JtXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwuYXR0YWNoVW5pZm9ybXMobmFtZSwgdW5pZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBcImFycmF5XCIgPT0gdW5pZm9ybXMudHlwZVxuICAgICAgICAgICAgICAgICAgICA/IHVuaWZvcm1zLnZhbHVlLmZvckVhY2goKHVuaWZvcm0sIGkpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5hdHRhY2hVbmlmb3JtcyhgJHtuYW1lfVske2l9XWAsIHVuaWZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IFwic3RydWN0XCIgPT0gdW5pZm9ybXMudHlwZVxuICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKHVuaWZvcm1zLnZhbHVlKS5mb3JFYWNoKChbdW5pZm9ybSwgaV0pID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5hdHRhY2hVbmlmb3JtcyhgJHtuYW1lfS4ke3VuaWZvcm19YCwgaSlcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogKF9taW5pR2wuZGVidWcoXCJNYXRlcmlhbC5hdHRhY2hVbmlmb3Jtc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybTogdW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwudW5pZm9ybUluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm06IHVuaWZvcm1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5wcm9ncmFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgVW5pZm9ybToge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgdmFsdWU6IGNsYXNzIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgICAgICAgICAgICAgICAodGhpcy50eXBlID0gXCJmbG9hdFwiKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICAgICh0aGlzLnR5cGVGbiA9XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBmbG9hdDogXCIxZlwiLFxuICAgICAgICAgICAgICAgICAgICAgIGludDogXCIxaVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHZlYzI6IFwiMmZ2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgdmVjMzogXCIzZnZcIixcbiAgICAgICAgICAgICAgICAgICAgICB2ZWM0OiBcIjRmdlwiLFxuICAgICAgICAgICAgICAgICAgICAgIG1hdDQ6IFwiTWF0cml4NGZ2XCIsXG4gICAgICAgICAgICAgICAgICAgIH1bdGhpcy50eXBlXSB8fCBcIjFmXCIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpcy52YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0W2B1bmlmb3JtJHt0aGlzLnR5cGVGbn1gXShcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAwID09PSB0aGlzLnR5cGVGbi5pbmRleE9mKFwiTWF0cml4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMudHJhbnNwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgMCA9PT0gdGhpcy50eXBlRm4uaW5kZXhPZihcIk1hdHJpeFwiKSA/IHRoaXMudmFsdWUgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vZSAtIG5hbWVcbiAgICAgICAgICAgICAgICAvL3QgLSB0eXBlXG4gICAgICAgICAgICAgICAgLy9uIC0gbGVuZ3RoXG4gICAgICAgICAgICAgICAgZ2V0RGVjbGFyYXRpb24obmFtZSwgdHlwZSwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB1bmlmb3JtID0gdGhpcztcbiAgICAgICAgICAgICAgICAgIGlmICh1bmlmb3JtLmV4Y2x1ZGVGcm9tICE9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImFycmF5XCIgPT09IHVuaWZvcm0udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS52YWx1ZVswXS5nZXREZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybS52YWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcbmNvbnN0IGludCAke25hbWV9X2xlbmd0aCA9ICR7dW5pZm9ybS52YWx1ZS5sZW5ndGh9O2BcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJ1Y3RcIiA9PT0gdW5pZm9ybS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVfbm9fcHJlZml4ID0gbmFtZS5yZXBsYWNlKFwidV9cIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lX25vX3ByZWZpeCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfbm9fcHJlZml4LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZV9ub19wcmVmaXguc2xpY2UoMSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYHVuaWZvcm0gc3RydWN0ICR7bmFtZV9ub19wcmVmaXh9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModW5pZm9ybS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChbbmFtZSwgdW5pZm9ybV0pID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXREZWNsYXJhdGlvbihuYW1lLCB0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXnVuaWZvcm0vLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIlwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG59ICR7bmFtZX0ke2xlbmd0aCA+IDAgPyBgWyR7bGVuZ3RofV1gIDogXCJcIn07YFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB1bmlmb3JtICR7dW5pZm9ybS50eXBlfSAke25hbWV9JHtcbiAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPiAwID8gYFske2xlbmd0aH1dYCA6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfTtgO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBQbGFuZUdlb21ldHJ5OiB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICB2YWx1ZTogY2xhc3Mge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIG4sIGksIG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LmNyZWF0ZUJ1ZmZlcigpLFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5hdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgX21pbmlHbC5BdHRyaWJ1dGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250ZXh0LkFSUkFZX0JVRkZFUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgdXY6IG5ldyBfbWluaUdsLkF0dHJpYnV0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRleHQuQVJSQVlfQlVGRkVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICB1dk5vcm06IG5ldyBfbWluaUdsLkF0dHJpYnV0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRleHQuQVJSQVlfQlVGRkVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleDogbmV3IF9taW5pR2wuQXR0cmlidXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogY29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBjb250ZXh0LlVOU0lHTkVEX1NIT1JULFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUb3BvbG9neShuLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQsIG9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VG9wb2xvZ3koZSA9IDEsIHQgPSAxKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuID0gdGhpcztcbiAgICAgICAgICAgICAgICAgIChuLnhTZWdDb3VudCA9IGUpLFxuICAgICAgICAgICAgICAgICAgICAobi55U2VnQ291bnQgPSB0KSxcbiAgICAgICAgICAgICAgICAgICAgKG4udmVydGV4Q291bnQgPSAobi54U2VnQ291bnQgKyAxKSAqIChuLnlTZWdDb3VudCArIDEpKSxcbiAgICAgICAgICAgICAgICAgICAgKG4ucXVhZENvdW50ID0gbi54U2VnQ291bnQgKiBuLnlTZWdDb3VudCAqIDIpLFxuICAgICAgICAgICAgICAgICAgICAobi5hdHRyaWJ1dGVzLnV2LnZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgMiAqIG4udmVydGV4Q291bnRcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChuLmF0dHJpYnV0ZXMudXZOb3JtLnZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgMiAqIG4udmVydGV4Q291bnRcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChuLmF0dHJpYnV0ZXMuaW5kZXgudmFsdWVzID0gbmV3IFVpbnQxNkFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgIDMgKiBuLnF1YWRDb3VudFxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDw9IG4ueVNlZ0NvdW50OyBlKyspXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDw9IG4ueFNlZ0NvdW50OyB0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpID0gZSAqIChuLnhTZWdDb3VudCArIDEpICsgdDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoKG4uYXR0cmlidXRlcy51di52YWx1ZXNbMiAqIGldID0gdCAvIG4ueFNlZ0NvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChuLmF0dHJpYnV0ZXMudXYudmFsdWVzWzIgKiBpICsgMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAxIC0gZSAvIG4ueVNlZ0NvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChuLmF0dHJpYnV0ZXMudXZOb3JtLnZhbHVlc1syICogaV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAodCAvIG4ueFNlZ0NvdW50KSAqIDIgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChuLmF0dHJpYnV0ZXMudXZOb3JtLnZhbHVlc1syICogaSArIDFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgMSAtIChlIC8gbi55U2VnQ291bnQpICogMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0IDwgbi54U2VnQ291bnQgJiYgZSA8IG4ueVNlZ0NvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IGUgKiBuLnhTZWdDb3VudCArIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAobi5hdHRyaWJ1dGVzLmluZGV4LnZhbHVlc1s2ICogc10gPSBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKG4uYXR0cmlidXRlcy5pbmRleC52YWx1ZXNbNiAqIHMgKyAxXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArIDEgKyBuLnhTZWdDb3VudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChuLmF0dHJpYnV0ZXMuaW5kZXgudmFsdWVzWzYgKiBzICsgMl0gPSBpICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChuLmF0dHJpYnV0ZXMuaW5kZXgudmFsdWVzWzYgKiBzICsgM10gPSBpICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChuLmF0dHJpYnV0ZXMuaW5kZXgudmFsdWVzWzYgKiBzICsgNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKyAxICsgbi54U2VnQ291bnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAobi5hdHRyaWJ1dGVzLmluZGV4LnZhbHVlc1s2ICogcyArIDVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICsgMiArIG4ueFNlZ0NvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG4uYXR0cmlidXRlcy51di51cGRhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgbi5hdHRyaWJ1dGVzLnV2Tm9ybS51cGRhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgbi5hdHRyaWJ1dGVzLmluZGV4LnVwZGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBfbWluaUdsLmRlYnVnKFwiR2VvbWV0cnkuc2V0VG9wb2xvZ3lcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIHV2OiBuLmF0dHJpYnV0ZXMudXYsXG4gICAgICAgICAgICAgICAgICAgICAgdXZOb3JtOiBuLmF0dHJpYnV0ZXMudXZOb3JtLFxuICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBuLmF0dHJpYnV0ZXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRTaXplKHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgb3JpZW50YXRpb24gPSBcInh6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgIChnZW9tZXRyeS53aWR0aCA9IHdpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgKGdlb21ldHJ5LmhlaWdodCA9IGhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgIChnZW9tZXRyeS5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgKGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmFsdWVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi52YWx1ZXMubGVuZ3RoID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgMyAqIGdlb21ldHJ5LnZlcnRleENvdW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAgIChnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICAzICogZ2VvbWV0cnkudmVydGV4Q291bnRcbiAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG8gPSB3aWR0aCAvIC0yLFxuICAgICAgICAgICAgICAgICAgICByID0gaGVpZ2h0IC8gLTIsXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdlb21ldHJ5LnhTZWdDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBnZW9tZXRyeS55U2VnQ291bnQ7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCB5SW5kZXggPSAwOyB5SW5kZXggPD0gZ2VvbWV0cnkueVNlZ0NvdW50OyB5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gciArIHlJbmRleCAqIHNlZ21lbnRfaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgIGxldCB4SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIHhJbmRleCA8PSBnZW9tZXRyeS54U2VnQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgeEluZGV4KytcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IG8gKyB4SW5kZXggKiBzZWdtZW50X3dpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHlJbmRleCAqIChnZW9tZXRyeS54U2VnQ291bnQgKyAxKSArIHhJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAoZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi52YWx1ZXNbXG4gICAgICAgICAgICAgICAgICAgICAgICAzICogbCArIFwieHl6XCIuaW5kZXhPZihvcmllbnRhdGlvblswXSlcbiAgICAgICAgICAgICAgICAgICAgICBdID0gciksXG4gICAgICAgICAgICAgICAgICAgICAgICAoZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi52YWx1ZXNbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDMgKiBsICsgXCJ4eXpcIi5pbmRleE9mKG9yaWVudGF0aW9uWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSA9IC10KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi51cGRhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgX21pbmlHbC5kZWJ1ZyhcIkdlb21ldHJ5LnNldFNpemVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTWVzaDoge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgdmFsdWU6IGNsYXNzIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcihnZW9tZXRyeSwgbWF0ZXJpYWwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc2ggPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgKG1lc2guZ2VvbWV0cnkgPSBnZW9tZXRyeSksXG4gICAgICAgICAgICAgICAgICAgIChtZXNoLm1hdGVyaWFsID0gbWF0ZXJpYWwpLFxuICAgICAgICAgICAgICAgICAgICAobWVzaC53aXJlZnJhbWUgPSAhMSksXG4gICAgICAgICAgICAgICAgICAgIChtZXNoLmF0dHJpYnV0ZUluc3RhbmNlcyA9IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzaC5nZW9tZXRyeS5hdHRyaWJ1dGVzKS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICAgIChbZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5hdHRyaWJ1dGVJbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogYXR0cmlidXRlLmF0dGFjaChlLCBtZXNoLm1hdGVyaWFsLnByb2dyYW0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBfbWluaUdsLm1lc2hlcy5wdXNoKG1lc2gpLFxuICAgICAgICAgICAgICAgICAgICBfbWluaUdsLmRlYnVnKFwiTWVzaC5jb25zdHJ1Y3RvclwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzaDogbWVzaCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRyYXcoKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LnVzZVByb2dyYW0odGhpcy5tYXRlcmlhbC5wcm9ncmFtKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3JtSW5zdGFuY2VzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgKHsgdW5pZm9ybTogZSwgbG9jYXRpb246IHQgfSkgPT4gZS51cGRhdGUodClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVJbnN0YW5jZXMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgICAgICAoeyBhdHRyaWJ1dGU6IGUsIGxvY2F0aW9uOiB0IH0pID0+IGUudXNlKHQpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0VsZW1lbnRzKFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2lyZWZyYW1lID8gY29udGV4dC5MSU5FUyA6IGNvbnRleHQuVFJJQU5HTEVTLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleC52YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuVU5TSUdORURfU0hPUlQsXG4gICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmUoKSB7XG4gICAgICAgICAgICAgICAgICBfbWluaUdsLm1lc2hlcyA9IF9taW5pR2wubWVzaGVzLmZpbHRlcigoZSkgPT4gZSAhPSB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQXR0cmlidXRlOiB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICB2YWx1ZTogY2xhc3Mge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKGUpIHtcbiAgICAgICAgICAgICAgICAgICh0aGlzLnR5cGUgPSBjb250ZXh0LkZMT0FUKSxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMubm9ybWFsaXplZCA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuYnVmZmVyID0gY29udGV4dC5jcmVhdGVCdWZmZXIoKSksXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgZSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpcy52YWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRleHQuYmluZEJ1ZmZlcih0aGlzLnRhcmdldCwgdGhpcy5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmJ1ZmZlckRhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5TVEFUSUNfRFJBV1xuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXR0YWNoKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBjb250ZXh0LmdldEF0dHJpYkxvY2F0aW9uKHQsIGUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPT09IGNvbnRleHQuQVJSQVlfQlVGRkVSICYmXG4gICAgICAgICAgICAgICAgICAgICAgKGNvbnRleHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobiksXG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIG5cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVzZShlKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LmJpbmRCdWZmZXIodGhpcy50YXJnZXQsIHRoaXMuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPT09IGNvbnRleHQuQVJSQVlfQlVGRkVSICYmXG4gICAgICAgICAgICAgICAgICAgICAgKGNvbnRleHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoZSksXG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYSA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbiAgICAgICAgX21pbmlHbC5jb21tb25Vbmlmb3JtcyA9IHtcbiAgICAgICAgICBwcm9qZWN0aW9uTWF0cml4OiBuZXcgX21pbmlHbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgIHR5cGU6IFwibWF0NFwiLFxuICAgICAgICAgICAgdmFsdWU6IGEsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbW9kZWxWaWV3TWF0cml4OiBuZXcgX21pbmlHbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgIHR5cGU6IFwibWF0NFwiLFxuICAgICAgICAgICAgdmFsdWU6IGEsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgcmVzb2x1dGlvbjogbmV3IF9taW5pR2wuVW5pZm9ybSh7XG4gICAgICAgICAgICB0eXBlOiBcInZlYzJcIixcbiAgICAgICAgICAgIHZhbHVlOiBbMSwgMV0sXG4gICAgICAgICAgfSksXG4gICAgICAgICAgYXNwZWN0UmF0aW86IG5ldyBfbWluaUdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgdHlwZTogXCJmbG9hdFwiLFxuICAgICAgICAgICAgdmFsdWU6IDEsXG4gICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzZXRTaXplKGUgPSA2NDAsIHQgPSA0ODApIHtcbiAgICAgICAgKHRoaXMud2lkdGggPSBlKSxcbiAgICAgICAgICAodGhpcy5oZWlnaHQgPSB0KSxcbiAgICAgICAgICAodGhpcy5jYW52YXMud2lkdGggPSBlKSxcbiAgICAgICAgICAodGhpcy5jYW52YXMuaGVpZ2h0ID0gdCksXG4gICAgICAgICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCBlLCB0KSxcbiAgICAgICAgICAodGhpcy5jb21tb25Vbmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlID0gW2UsIHRdKSxcbiAgICAgICAgICAodGhpcy5jb21tb25Vbmlmb3Jtcy5hc3BlY3RSYXRpby52YWx1ZSA9IGUgLyB0KSxcbiAgICAgICAgICB0aGlzLmRlYnVnKFwiTWluaUdMLnNldFNpemVcIiwge1xuICAgICAgICAgICAgd2lkdGg6IGUsXG4gICAgICAgICAgICBoZWlnaHQ6IHQsXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvL2xlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyXG4gICAgICBzZXRPcnRob2dyYXBoaWNDYW1lcmEoZSA9IDAsIHQgPSAwLCBuID0gMCwgaSA9IC0yZTMsIHMgPSAyZTMpIHtcbiAgICAgICAgKHRoaXMuY29tbW9uVW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC52YWx1ZSA9IFtcbiAgICAgICAgICAyIC8gdGhpcy53aWR0aCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDIgLyB0aGlzLmhlaWdodCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDIgLyAoaSAtIHMpLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgZSxcbiAgICAgICAgICB0LFxuICAgICAgICAgIG4sXG4gICAgICAgICAgMSxcbiAgICAgICAgXSksXG4gICAgICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgICAgIFwic2V0T3J0aG9ncmFwaGljQ2FtZXJhXCIsXG4gICAgICAgICAgICB0aGlzLmNvbW1vblVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgudmFsdWVcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCksXG4gICAgICAgICAgdGhpcy5nbC5jbGVhckRlcHRoKDEpLFxuICAgICAgICAgIHRoaXMubWVzaGVzLmZvckVhY2goKGUpID0+IGUuZHJhdygpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1NldHMgaW5pdGlhbCBwcm9wZXJ0aWVzXG4gICAgZnVuY3Rpb24gZShvYmplY3QsIHByb3BlcnR5TmFtZSwgdmFsKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwcm9wZXJ0eU5hbWUgaW4gb2JqZWN0XG4gICAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgOiAob2JqZWN0W3Byb3BlcnR5TmFtZV0gPSB2YWwpLFxuICAgICAgICBvYmplY3RcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy9HcmFkaWVudCBvYmplY3RcbiAgICBjbGFzcyBHcmFkaWVudCB7XG4gICAgICBjb25zdHJ1Y3RvciguLi50KSB7XG4gICAgICAgIGUodGhpcywgXCJlbFwiLCB2b2lkIDApLFxuICAgICAgICAgIGUodGhpcywgXCJjc3NWYXJSZXRyaWVzXCIsIDApLFxuICAgICAgICAgIGUodGhpcywgXCJtYXhDc3NWYXJSZXRyaWVzXCIsIDIwMCksXG4gICAgICAgICAgZSh0aGlzLCBcImFuZ2xlXCIsIDApLFxuICAgICAgICAgIGUodGhpcywgXCJpc0xvYWRlZENsYXNzXCIsICExKSxcbiAgICAgICAgICBlKHRoaXMsIFwiaXNTY3JvbGxpbmdcIiwgITEpLFxuICAgICAgICAgIC8qZSh0aGlzLCBcImlzU3RhdGljXCIsIG8uZGlzYWJsZUFtYmllbnRBbmltYXRpb25zKCkpLCovIGUoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgXCJzY3JvbGxpbmdUaW1lb3V0XCIsXG4gICAgICAgICAgICB2b2lkIDBcbiAgICAgICAgICApLFxuICAgICAgICAgIGUodGhpcywgXCJzY3JvbGxpbmdSZWZyZXNoRGVsYXlcIiwgMjAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwiaXNJbnRlcnNlY3RpbmdcIiwgITEpLFxuICAgICAgICAgIGUodGhpcywgXCJzaGFkZXJGaWxlc1wiLCB2b2lkIDApLFxuICAgICAgICAgIGUodGhpcywgXCJ2ZXJ0ZXhTaGFkZXJcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwic2VjdGlvbkNvbG9yc1wiLCB2b2lkIDApLFxuICAgICAgICAgIGUodGhpcywgXCJjb21wdXRlZENhbnZhc1N0eWxlXCIsIHZvaWQgMCksXG4gICAgICAgICAgZSh0aGlzLCBcImNvbmZcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwidW5pZm9ybXNcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwidFwiLCAxMjUzMTA2KSxcbiAgICAgICAgICBlKHRoaXMsIFwibGFzdFwiLCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwid2lkdGhcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwibWluV2lkdGhcIiwgMTExMSksXG4gICAgICAgICAgZSh0aGlzLCBcImhlaWdodFwiLCA2MDApLFxuICAgICAgICAgIGUodGhpcywgXCJ4U2VnQ291bnRcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwieVNlZ0NvdW50XCIsIHZvaWQgMCksXG4gICAgICAgICAgZSh0aGlzLCBcIm1lc2hcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwibWF0ZXJpYWxcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwiZ2VvbWV0cnlcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwibWluaWdsXCIsIHZvaWQgMCksXG4gICAgICAgICAgZSh0aGlzLCBcInNjcm9sbE9ic2VydmVyXCIsIHZvaWQgMCksXG4gICAgICAgICAgZSh0aGlzLCBcImFtcFwiLCAzMjApLFxuICAgICAgICAgIGUodGhpcywgXCJzZWVkXCIsIDUpLFxuICAgICAgICAgIGUodGhpcywgXCJmcmVxWFwiLCAxNGUtNSksXG4gICAgICAgICAgZSh0aGlzLCBcImZyZXFZXCIsIDI5ZS01KSxcbiAgICAgICAgICBlKHRoaXMsIFwiZnJlcURlbHRhXCIsIDFlLTUpLFxuICAgICAgICAgIGUodGhpcywgXCJhY3RpdmVDb2xvcnNcIiwgWzEsIDEsIDEsIDFdKSxcbiAgICAgICAgICBlKHRoaXMsIFwiaXNNZXRhS2V5XCIsICExKSxcbiAgICAgICAgICBlKHRoaXMsIFwiaXNHcmFkaWVudExlZ2VuZFZpc2libGVcIiwgITEpLFxuICAgICAgICAgIGUodGhpcywgXCJpc01vdXNlRG93blwiLCAhMSksXG4gICAgICAgICAgZSh0aGlzLCBcImhhbmRsZVNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zY3JvbGxpbmdUaW1lb3V0KSxcbiAgICAgICAgICAgICAgKHRoaXMuc2Nyb2xsaW5nVGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxFbmQsXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmdSZWZyZXNoRGVsYXlcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHRoaXMuaXNHcmFkaWVudExlZ2VuZFZpc2libGUgJiYgdGhpcy5oaWRlR3JhZGllbnRMZWdlbmQoKSxcbiAgICAgICAgICAgICAgdGhpcy5jb25mLnBsYXlpbmcgJiYgKCh0aGlzLmlzU2Nyb2xsaW5nID0gITApLCB0aGlzLnBhdXNlKCkpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGUodGhpcywgXCJoYW5kbGVTY3JvbGxFbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgKHRoaXMuaXNTY3JvbGxpbmcgPSAhMSksIHRoaXMuaXNJbnRlcnNlY3RpbmcgJiYgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZSh0aGlzLCBcInJlc2l6ZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAodGhpcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoKSxcbiAgICAgICAgICAgICAgdGhpcy5taW5pZ2wuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCksXG4gICAgICAgICAgICAgIHRoaXMubWluaWdsLnNldE9ydGhvZ3JhcGhpY0NhbWVyYSgpLFxuICAgICAgICAgICAgICAodGhpcy54U2VnQ291bnQgPSBNYXRoLmNlaWwodGhpcy53aWR0aCAqIHRoaXMuY29uZi5kZW5zaXR5WzBdKSksXG4gICAgICAgICAgICAgICh0aGlzLnlTZWdDb3VudCA9IE1hdGguY2VpbCh0aGlzLmhlaWdodCAqIHRoaXMuY29uZi5kZW5zaXR5WzFdKSksXG4gICAgICAgICAgICAgIHRoaXMubWVzaC5nZW9tZXRyeS5zZXRUb3BvbG9neSh0aGlzLnhTZWdDb3VudCwgdGhpcy55U2VnQ291bnQpLFxuICAgICAgICAgICAgICB0aGlzLm1lc2guZ2VvbWV0cnkuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCksXG4gICAgICAgICAgICAgICh0aGlzLm1lc2gubWF0ZXJpYWwudW5pZm9ybXMudV9zaGFkb3dfcG93ZXIudmFsdWUgPVxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPCA2MDAgPyA1IDogNik7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZSh0aGlzLCBcImhhbmRsZU1vdXNlRG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0dyYWRpZW50TGVnZW5kVmlzaWJsZSAmJlxuICAgICAgICAgICAgICAoKHRoaXMuaXNNZXRhS2V5ID0gZS5tZXRhS2V5KSxcbiAgICAgICAgICAgICAgKHRoaXMuaXNNb3VzZURvd24gPSAhMCksXG4gICAgICAgICAgICAgICExID09PSB0aGlzLmNvbmYucGxheWluZyAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZSh0aGlzLCBcImhhbmRsZU1vdXNlVXBcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc01vdXNlRG93biA9ICExO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGUodGhpcywgXCJhbmltYXRlXCIsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkU2tpcEZyYW1lKGUpIHx8IHRoaXMuaXNNb3VzZURvd24pIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgodGhpcy50ICs9IE1hdGgubWluKGUgLSB0aGlzLmxhc3QsIDFlMyAvIDE1KSksXG4gICAgICAgICAgICAgICAgKHRoaXMubGFzdCA9IGUpLFxuICAgICAgICAgICAgICAgIHRoaXMuaXNNb3VzZURvd24pXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGxldCBlID0gMTYwO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNNZXRhS2V5ICYmIChlID0gLTE2MCksICh0aGlzLnQgKz0gZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKHRoaXMubWVzaC5tYXRlcmlhbC51bmlmb3Jtcy51X3RpbWUudmFsdWUgPSB0aGlzLnQpLFxuICAgICAgICAgICAgICAgIHRoaXMubWluaWdsLnJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDAgIT09IHRoaXMubGFzdCAmJiB0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taW5pZ2wucmVuZGVyKCksIHZvaWQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAvKnRoaXMuaXNJbnRlcnNlY3RpbmcgJiYgKi8gKHRoaXMuY29uZi5wbGF5aW5nIHx8XG4gICAgICAgICAgICAgIHRoaXMuaXNNb3VzZURvd24pICYmXG4gICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGUpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGUodGhpcywgXCJhZGRJc0xvYWRlZENsYXNzXCIsICgpID0+IHtcbiAgICAgICAgICAgIC8qdGhpcy5pc0ludGVyc2VjdGluZyAmJiAqLyAhdGhpcy5pc0xvYWRlZENsYXNzICYmXG4gICAgICAgICAgICAgICgodGhpcy5pc0xvYWRlZENsYXNzID0gITApLFxuICAgICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJpc0xvYWRlZFwiKSxcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJpc0xvYWRlZFwiKTtcbiAgICAgICAgICAgICAgfSwgM2UzKSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZSh0aGlzLCBcInBhdXNlXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZi5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZSh0aGlzLCBcInBsYXlcIiwgKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSksICh0aGlzLmNvbmYucGxheWluZyA9IHRydWUpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGUodGhpcywgXCJpbml0R3JhZGllbnRcIiwgKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgKHRoaXMuc2hhZGVyRmlsZXMgPSB7XG4gICAgICAgICAgdmVydGV4OlxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdl9jb2xvcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBmbG9hdCB0aW1lID0gdV90aW1lICogdV9nbG9iYWwubm9pc2VTcGVlZDtcXG5cXG4gIHZlYzIgbm9pc2VDb29yZCA9IHJlc29sdXRpb24gKiB1dk5vcm0gKiB1X2dsb2JhbC5ub2lzZUZyZXE7XFxuXFxuICB2ZWMyIHN0ID0gMS4gLSB1dk5vcm0ueHk7XFxuXFxuICAvL1xcbiAgLy8gVGlsdGluZyB0aGUgcGxhbmVcXG4gIC8vXFxuXFxuICAvLyBGcm9udC10by1iYWNrIHRpbHRcXG4gIGZsb2F0IHRpbHQgPSByZXNvbHV0aW9uLnkgLyAyLjAgKiB1dk5vcm0ueTtcXG5cXG4gIC8vIExlZnQtdG8tcmlnaHQgYW5nbGVcXG4gIGZsb2F0IGluY2xpbmUgPSByZXNvbHV0aW9uLnggKiB1dk5vcm0ueCAvIDIuMCAqIHVfdmVydERlZm9ybS5pbmNsaW5lO1xcblxcbiAgLy8gVXAtZG93biBzaGlmdCB0byBvZmZzZXQgaW5jbGluZVxcbiAgZmxvYXQgb2Zmc2V0ID0gcmVzb2x1dGlvbi54IC8gMi4wICogdV92ZXJ0RGVmb3JtLmluY2xpbmUgKiBtaXgodV92ZXJ0RGVmb3JtLm9mZnNldEJvdHRvbSwgdV92ZXJ0RGVmb3JtLm9mZnNldFRvcCwgdXYueSk7XFxuXFxuICAvL1xcbiAgLy8gVmVydGV4IG5vaXNlXFxuICAvL1xcblxcbiAgZmxvYXQgbm9pc2UgPSBzbm9pc2UodmVjMyhcXG4gICAgbm9pc2VDb29yZC54ICogdV92ZXJ0RGVmb3JtLm5vaXNlRnJlcS54ICsgdGltZSAqIHVfdmVydERlZm9ybS5ub2lzZUZsb3csXFxuICAgIG5vaXNlQ29vcmQueSAqIHVfdmVydERlZm9ybS5ub2lzZUZyZXEueSxcXG4gICAgdGltZSAqIHVfdmVydERlZm9ybS5ub2lzZVNwZWVkICsgdV92ZXJ0RGVmb3JtLm5vaXNlU2VlZFxcbiAgKSkgKiB1X3ZlcnREZWZvcm0ubm9pc2VBbXA7XFxuXFxuICAvLyBGYWRlIG5vaXNlIHRvIHplcm8gYXQgZWRnZXNcXG4gIG5vaXNlICo9IDEuMCAtIHBvdyhhYnModXZOb3JtLnkpLCAyLjApO1xcblxcbiAgLy8gQ2xhbXAgdG8gMFxcbiAgbm9pc2UgPSBtYXgoMC4wLCBub2lzZSk7XFxuXFxuICB2ZWMzIHBvcyA9IHZlYzMoXFxuICAgIHBvc2l0aW9uLngsXFxuICAgIHBvc2l0aW9uLnkgKyB0aWx0ICsgaW5jbGluZSArIG5vaXNlIC0gb2Zmc2V0LFxcbiAgICBwb3NpdGlvbi56XFxuICApO1xcblxcbiAgLy9cXG4gIC8vIFZlcnRleCBjb2xvciwgdG8gYmUgcGFzc2VkIHRvIGZyYWdtZW50IHNoYWRlclxcbiAgLy9cXG5cXG4gIGlmICh1X2FjdGl2ZV9jb2xvcnNbMF0gPT0gMS4pIHtcXG4gICAgdl9jb2xvciA9IHVfYmFzZUNvbG9yO1xcbiAgfVxcblxcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCB1X3dhdmVMYXllcnNfbGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKHVfYWN0aXZlX2NvbG9yc1tpICsgMV0gPT0gMS4pIHtcXG4gICAgICBXYXZlTGF5ZXJzIGxheWVyID0gdV93YXZlTGF5ZXJzW2ldO1xcblxcbiAgICAgIGZsb2F0IG5vaXNlID0gc21vb3Roc3RlcChcXG4gICAgICAgIGxheWVyLm5vaXNlRmxvb3IsXFxuICAgICAgICBsYXllci5ub2lzZUNlaWwsXFxuICAgICAgICBzbm9pc2UodmVjMyhcXG4gICAgICAgICAgbm9pc2VDb29yZC54ICogbGF5ZXIubm9pc2VGcmVxLnggKyB0aW1lICogbGF5ZXIubm9pc2VGbG93LFxcbiAgICAgICAgICBub2lzZUNvb3JkLnkgKiBsYXllci5ub2lzZUZyZXEueSxcXG4gICAgICAgICAgdGltZSAqIGxheWVyLm5vaXNlU3BlZWQgKyBsYXllci5ub2lzZVNlZWRcXG4gICAgICAgICkpIC8gMi4wICsgMC41XFxuICAgICAgKTtcXG5cXG4gICAgICB2X2NvbG9yID0gYmxlbmROb3JtYWwodl9jb2xvciwgbGF5ZXIuY29sb3IsIHBvdyhub2lzZSwgNC4pKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy9cXG4gIC8vIEZpbmlzaFxcbiAgLy9cXG5cXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zLCAxLjApO1xcbn1cIixcbiAgICAgICAgICBub2lzZTpcbiAgICAgICAgICAgIFwiLy9cXG4vLyBEZXNjcmlwdGlvbiA6IEFycmF5IGFuZCB0ZXh0dXJlbGVzcyBHTFNMIDJELzNELzREIHNpbXBsZXhcXG4vLyAgICAgICAgICAgICAgIG5vaXNlIGZ1bmN0aW9ucy5cXG4vLyAgICAgIEF1dGhvciA6IElhbiBNY0V3YW4sIEFzaGltYSBBcnRzLlxcbi8vICBNYWludGFpbmVyIDogc3RlZ3VcXG4vLyAgICAgTGFzdG1vZCA6IDIwMTEwODIyIChpam0pXFxuLy8gICAgIExpY2Vuc2UgOiBDb3B5cmlnaHQgKEMpIDIwMTEgQXNoaW1hIEFydHMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuLy8gICAgICAgICAgICAgICBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUuXFxuLy8gICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vYXNoaW1hL3dlYmdsLW5vaXNlXFxuLy8gICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vc3RlZ3Uvd2ViZ2wtbm9pc2VcXG4vL1xcblxcbnZlYzMgbW9kMjg5KHZlYzMgeCkge1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG59XFxuXFxudmVjNCBtb2QyODkodmVjNCB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5cXG52ZWM0IHBlcm11dGUodmVjNCB4KSB7XFxuICAgIHJldHVybiBtb2QyODkoKCh4KjM0LjApKzEuMCkqeCk7XFxufVxcblxcbnZlYzQgdGF5bG9ySW52U3FydCh2ZWM0IHIpXFxue1xcbiAgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjtcXG59XFxuXFxuZmxvYXQgc25vaXNlKHZlYzMgdilcXG57XFxuICBjb25zdCB2ZWMyICBDID0gdmVjMigxLjAvNi4wLCAxLjAvMy4wKSA7XFxuICBjb25zdCB2ZWM0ICBEID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAyLjApO1xcblxcbi8vIEZpcnN0IGNvcm5lclxcbiAgdmVjMyBpICA9IGZsb29yKHYgKyBkb3QodiwgQy55eXkpICk7XFxuICB2ZWMzIHgwID0gICB2IC0gaSArIGRvdChpLCBDLnh4eCkgO1xcblxcbi8vIE90aGVyIGNvcm5lcnNcXG4gIHZlYzMgZyA9IHN0ZXAoeDAueXp4LCB4MC54eXopO1xcbiAgdmVjMyBsID0gMS4wIC0gZztcXG4gIHZlYzMgaTEgPSBtaW4oIGcueHl6LCBsLnp4eSApO1xcbiAgdmVjMyBpMiA9IG1heCggZy54eXosIGwuenh5ICk7XFxuXFxuICAvLyAgIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4eDtcXG4gIC8vICAgeDEgPSB4MCAtIGkxICArIDEuMCAqIEMueHh4O1xcbiAgLy8gICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHg7XFxuICAvLyAgIHgzID0geDAgLSAxLjAgKyAzLjAgKiBDLnh4eDtcXG4gIHZlYzMgeDEgPSB4MCAtIGkxICsgQy54eHg7XFxuICB2ZWMzIHgyID0geDAgLSBpMiArIEMueXl5OyAvLyAyLjAqQy54ID0gMS8zID0gQy55XFxuICB2ZWMzIHgzID0geDAgLSBELnl5eTsgICAgICAvLyAtMS4wKzMuMCpDLnggPSAtMC41ID0gLUQueVxcblxcbi8vIFBlcm11dGF0aW9uc1xcbiAgaSA9IG1vZDI4OShpKTtcXG4gIHZlYzQgcCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoXFxuICAgICAgICAgICAgaS56ICsgdmVjNCgwLjAsIGkxLnosIGkyLnosIDEuMCApKVxcbiAgICAgICAgICArIGkueSArIHZlYzQoMC4wLCBpMS55LCBpMi55LCAxLjAgKSlcXG4gICAgICAgICAgKyBpLnggKyB2ZWM0KDAuMCwgaTEueCwgaTIueCwgMS4wICkpO1xcblxcbi8vIEdyYWRpZW50czogN3g3IHBvaW50cyBvdmVyIGEgc3F1YXJlLCBtYXBwZWQgb250byBhbiBvY3RhaGVkcm9uLlxcbi8vIFRoZSByaW5nIHNpemUgMTcqMTcgPSAyODkgaXMgY2xvc2UgdG8gYSBtdWx0aXBsZSBvZiA0OSAoNDkqNiA9IDI5NClcXG4gIGZsb2F0IG5fID0gMC4xNDI4NTcxNDI4NTc7IC8vIDEuMC83LjBcXG4gIHZlYzMgIG5zID0gbl8gKiBELnd5eiAtIEQueHp4O1xcblxcbiAgdmVjNCBqID0gcCAtIDQ5LjAgKiBmbG9vcihwICogbnMueiAqIG5zLnopOyAgLy8gIG1vZChwLDcqNylcXG5cXG4gIHZlYzQgeF8gPSBmbG9vcihqICogbnMueik7XFxuICB2ZWM0IHlfID0gZmxvb3IoaiAtIDcuMCAqIHhfICk7ICAgIC8vIG1vZChqLE4pXFxuXFxuICB2ZWM0IHggPSB4XyAqbnMueCArIG5zLnl5eXk7XFxuICB2ZWM0IHkgPSB5XyAqbnMueCArIG5zLnl5eXk7XFxuICB2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XFxuXFxuICB2ZWM0IGIwID0gdmVjNCggeC54eSwgeS54eSApO1xcbiAgdmVjNCBiMSA9IHZlYzQoIHguencsIHkuencgKTtcXG5cXG4gIC8vdmVjNCBzMCA9IHZlYzQobGVzc1RoYW4oYjAsMC4wKSkqMi4wIC0gMS4wO1xcbiAgLy92ZWM0IHMxID0gdmVjNChsZXNzVGhhbihiMSwwLjApKSoyLjAgLSAxLjA7XFxuICB2ZWM0IHMwID0gZmxvb3IoYjApKjIuMCArIDEuMDtcXG4gIHZlYzQgczEgPSBmbG9vcihiMSkqMi4wICsgMS4wO1xcbiAgdmVjNCBzaCA9IC1zdGVwKGgsIHZlYzQoMC4wKSk7XFxuXFxuICB2ZWM0IGEwID0gYjAueHp5dyArIHMwLnh6eXcqc2gueHh5eSA7XFxuICB2ZWM0IGExID0gYjEueHp5dyArIHMxLnh6eXcqc2guenp3dyA7XFxuXFxuICB2ZWMzIHAwID0gdmVjMyhhMC54eSxoLngpO1xcbiAgdmVjMyBwMSA9IHZlYzMoYTAuencsaC55KTtcXG4gIHZlYzMgcDIgPSB2ZWMzKGExLnh5LGgueik7XFxuICB2ZWMzIHAzID0gdmVjMyhhMS56dyxoLncpO1xcblxcbi8vTm9ybWFsaXNlIGdyYWRpZW50c1xcbiAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XFxuICBwMCAqPSBub3JtLng7XFxuICBwMSAqPSBub3JtLnk7XFxuICBwMiAqPSBub3JtLno7XFxuICBwMyAqPSBub3JtLnc7XFxuXFxuLy8gTWl4IGZpbmFsIG5vaXNlIHZhbHVlXFxuICB2ZWM0IG0gPSBtYXgoMC42IC0gdmVjNChkb3QoeDAseDApLCBkb3QoeDEseDEpLCBkb3QoeDIseDIpLCBkb3QoeDMseDMpKSwgMC4wKTtcXG4gIG0gPSBtICogbTtcXG4gIHJldHVybiA0Mi4wICogZG90KCBtKm0sIHZlYzQoIGRvdChwMCx4MCksIGRvdChwMSx4MSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QocDIseDIpLCBkb3QocDMseDMpICkgKTtcXG59XCIsXG4gICAgICAgICAgYmxlbmQ6XG4gICAgICAgICAgICBcIi8vXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2phbWllb3dlbi9nbHNsLWJsZW5kXFxuLy9cXG5cXG4vLyBOb3JtYWxcXG5cXG52ZWMzIGJsZW5kTm9ybWFsKHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiBibGVuZDtcXG59XFxuXFxudmVjMyBibGVuZE5vcm1hbCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kTm9ybWFsKGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gU2NyZWVuXFxuXFxuZmxvYXQgYmxlbmRTY3JlZW4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gMS4wLSgoMS4wLWJhc2UpKigxLjAtYmxlbmQpKTtcXG59XFxuXFxudmVjMyBibGVuZFNjcmVlbih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZFNjcmVlbihiYXNlLnIsYmxlbmQuciksYmxlbmRTY3JlZW4oYmFzZS5nLGJsZW5kLmcpLGJsZW5kU2NyZWVuKGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRTY3JlZW4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZFNjcmVlbihiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVxcblxcbi8vIE11bHRpcGx5XFxuXFxudmVjMyBibGVuZE11bHRpcGx5KHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiBiYXNlKmJsZW5kO1xcbn1cXG5cXG52ZWMzIGJsZW5kTXVsdGlwbHkodmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZE11bHRpcGx5KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gT3ZlcmxheVxcblxcbmZsb2F0IGJsZW5kT3ZlcmxheShmbG9hdCBiYXNlLCBmbG9hdCBibGVuZCkge1xcblxcdHJldHVybiBiYXNlPDAuNT8oMi4wKmJhc2UqYmxlbmQpOigxLjAtMi4wKigxLjAtYmFzZSkqKDEuMC1ibGVuZCkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kT3ZlcmxheSh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZE92ZXJsYXkoYmFzZS5yLGJsZW5kLnIpLGJsZW5kT3ZlcmxheShiYXNlLmcsYmxlbmQuZyksYmxlbmRPdmVybGF5KGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRPdmVybGF5KHZlYzMgYmFzZSwgdmVjMyBibGVuZCwgZmxvYXQgb3BhY2l0eSkge1xcblxcdHJldHVybiAoYmxlbmRPdmVybGF5KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gSGFyZCBsaWdodFxcblxcbnZlYzMgYmxlbmRIYXJkTGlnaHQodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0cmV0dXJuIGJsZW5kT3ZlcmxheShibGVuZCxiYXNlKTtcXG59XFxuXFxudmVjMyBibGVuZEhhcmRMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kSGFyZExpZ2h0KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gU29mdCBsaWdodFxcblxcbmZsb2F0IGJsZW5kU29mdExpZ2h0KGZsb2F0IGJhc2UsIGZsb2F0IGJsZW5kKSB7XFxuXFx0cmV0dXJuIChibGVuZDwwLjUpPygyLjAqYmFzZSpibGVuZCtiYXNlKmJhc2UqKDEuMC0yLjAqYmxlbmQpKTooc3FydChiYXNlKSooMi4wKmJsZW5kLTEuMCkrMi4wKmJhc2UqKDEuMC1ibGVuZCkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kU29mdExpZ2h0KHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiB2ZWMzKGJsZW5kU29mdExpZ2h0KGJhc2UucixibGVuZC5yKSxibGVuZFNvZnRMaWdodChiYXNlLmcsYmxlbmQuZyksYmxlbmRTb2Z0TGlnaHQoYmFzZS5iLGJsZW5kLmIpKTtcXG59XFxuXFxudmVjMyBibGVuZFNvZnRMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kU29mdExpZ2h0KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gQ29sb3IgZG9kZ2VcXG5cXG5mbG9hdCBibGVuZENvbG9yRG9kZ2UoZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gKGJsZW5kPT0xLjApP2JsZW5kOm1pbihiYXNlLygxLjAtYmxlbmQpLDEuMCk7XFxufVxcblxcbnZlYzMgYmxlbmRDb2xvckRvZGdlKHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiB2ZWMzKGJsZW5kQ29sb3JEb2RnZShiYXNlLnIsYmxlbmQuciksYmxlbmRDb2xvckRvZGdlKGJhc2UuZyxibGVuZC5nKSxibGVuZENvbG9yRG9kZ2UoYmFzZS5iLGJsZW5kLmIpKTtcXG59XFxuXFxudmVjMyBibGVuZENvbG9yRG9kZ2UodmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZENvbG9yRG9kZ2UoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBDb2xvciBidXJuXFxuXFxuZmxvYXQgYmxlbmRDb2xvckJ1cm4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gKGJsZW5kPT0wLjApP2JsZW5kOm1heCgoMS4wLSgoMS4wLWJhc2UpL2JsZW5kKSksMC4wKTtcXG59XFxuXFxudmVjMyBibGVuZENvbG9yQnVybih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZENvbG9yQnVybihiYXNlLnIsYmxlbmQuciksYmxlbmRDb2xvckJ1cm4oYmFzZS5nLGJsZW5kLmcpLGJsZW5kQ29sb3JCdXJuKGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRDb2xvckJ1cm4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZENvbG9yQnVybihiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVxcblxcbi8vIFZpdmlkIExpZ2h0XFxuXFxuZmxvYXQgYmxlbmRWaXZpZExpZ2h0KGZsb2F0IGJhc2UsIGZsb2F0IGJsZW5kKSB7XFxuXFx0cmV0dXJuIChibGVuZDwwLjUpP2JsZW5kQ29sb3JCdXJuKGJhc2UsKDIuMCpibGVuZCkpOmJsZW5kQ29sb3JEb2RnZShiYXNlLCgyLjAqKGJsZW5kLTAuNSkpKTtcXG59XFxuXFxudmVjMyBibGVuZFZpdmlkTGlnaHQodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0cmV0dXJuIHZlYzMoYmxlbmRWaXZpZExpZ2h0KGJhc2UucixibGVuZC5yKSxibGVuZFZpdmlkTGlnaHQoYmFzZS5nLGJsZW5kLmcpLGJsZW5kVml2aWRMaWdodChiYXNlLmIsYmxlbmQuYikpO1xcbn1cXG5cXG52ZWMzIGJsZW5kVml2aWRMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kVml2aWRMaWdodChiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVxcblxcbi8vIExpZ2h0ZW5cXG5cXG5mbG9hdCBibGVuZExpZ2h0ZW4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gbWF4KGJsZW5kLGJhc2UpO1xcbn1cXG5cXG52ZWMzIGJsZW5kTGlnaHRlbih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZExpZ2h0ZW4oYmFzZS5yLGJsZW5kLnIpLGJsZW5kTGlnaHRlbihiYXNlLmcsYmxlbmQuZyksYmxlbmRMaWdodGVuKGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRMaWdodGVuKHZlYzMgYmFzZSwgdmVjMyBibGVuZCwgZmxvYXQgb3BhY2l0eSkge1xcblxcdHJldHVybiAoYmxlbmRMaWdodGVuKGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gTGluZWFyIGJ1cm5cXG5cXG5mbG9hdCBibGVuZExpbmVhckJ1cm4oZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHQvLyBOb3RlIDogU2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBCbGVuZFN1YnRyYWN0ZlxcblxcdHJldHVybiBtYXgoYmFzZStibGVuZC0xLjAsMC4wKTtcXG59XFxuXFxudmVjMyBibGVuZExpbmVhckJ1cm4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0Ly8gTm90ZSA6IFNhbWUgaW1wbGVtZW50YXRpb24gYXMgQmxlbmRTdWJ0cmFjdFxcblxcdHJldHVybiBtYXgoYmFzZStibGVuZC12ZWMzKDEuMCksdmVjMygwLjApKTtcXG59XFxuXFxudmVjMyBibGVuZExpbmVhckJ1cm4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZExpbmVhckJ1cm4oYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBMaW5lYXIgZG9kZ2VcXG5cXG5mbG9hdCBibGVuZExpbmVhckRvZGdlKGZsb2F0IGJhc2UsIGZsb2F0IGJsZW5kKSB7XFxuXFx0Ly8gTm90ZSA6IFNhbWUgaW1wbGVtZW50YXRpb24gYXMgQmxlbmRBZGRmXFxuXFx0cmV0dXJuIG1pbihiYXNlK2JsZW5kLDEuMCk7XFxufVxcblxcbnZlYzMgYmxlbmRMaW5lYXJEb2RnZSh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHQvLyBOb3RlIDogU2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBCbGVuZEFkZFxcblxcdHJldHVybiBtaW4oYmFzZStibGVuZCx2ZWMzKDEuMCkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kTGluZWFyRG9kZ2UodmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZExpbmVhckRvZGdlKGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gTGluZWFyIGxpZ2h0XFxuXFxuZmxvYXQgYmxlbmRMaW5lYXJMaWdodChmbG9hdCBiYXNlLCBmbG9hdCBibGVuZCkge1xcblxcdHJldHVybiBibGVuZDwwLjU/YmxlbmRMaW5lYXJCdXJuKGJhc2UsKDIuMCpibGVuZCkpOmJsZW5kTGluZWFyRG9kZ2UoYmFzZSwoMi4wKihibGVuZC0wLjUpKSk7XFxufVxcblxcbnZlYzMgYmxlbmRMaW5lYXJMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZExpbmVhckxpZ2h0KGJhc2UucixibGVuZC5yKSxibGVuZExpbmVhckxpZ2h0KGJhc2UuZyxibGVuZC5nKSxibGVuZExpbmVhckxpZ2h0KGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRMaW5lYXJMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kTGluZWFyTGlnaHQoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cIixcbiAgICAgICAgICBmcmFnbWVudDpcbiAgICAgICAgICAgIFwidmFyeWluZyB2ZWMzIHZfY29sb3I7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjMyBjb2xvciA9IHZfY29sb3I7XFxuICBpZiAodV9kYXJrZW5fdG9wID09IDEuMCkge1xcbiAgICB2ZWMyIHN0ID0gZ2xfRnJhZ0Nvb3JkLnh5L3Jlc29sdXRpb24ueHk7XFxuICAgIGNvbG9yLmcgLT0gcG93KHN0LnkgKyBzaW4oLTEyLjApICogc3QueCwgdV9zaGFkb3dfcG93ZXIpICogMC40O1xcbiAgfVxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG59XCIsXG4gICAgICAgIH0pLFxuICAgICAgICAgICh0aGlzLmNvbmYgPSB7XG4gICAgICAgICAgICBwcmVzZXROYW1lOiBcIlwiLFxuICAgICAgICAgICAgd2lyZWZyYW1lOiBmYWxzZSxcbiAgICAgICAgICAgIGRlbnNpdHk6IFswLjA2LCAwLjE2XSxcbiAgICAgICAgICAgIHpvb206IDEsXG4gICAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICAgIHBsYXlpbmc6IHRydWUsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImNhbnZhc1wiKS5sZW5ndGggPCAxXG4gICAgICAgICAgICA/IGNvbnNvbGUubG9nKFwiRElEIE5PVCBMT0FEIEhFUk8gU1RSSVBFIENBTlZBU1wiKVxuICAgICAgICAgICAgOiAoKHRoaXMubWluaWdsID0gbmV3IE1pbmlHbCh0aGlzLmVsLCBudWxsLCBudWxsLCAhMCkpLFxuICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwgJiZcbiAgICAgICAgICAgICAgICAgICgodGhpcy5jb21wdXRlZENhbnZhc1N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsKSksXG4gICAgICAgICAgICAgICAgICB0aGlzLndhaXRGb3JDc3NWYXJzKCkpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIC8qXG4gICAgICAgICAgdGhpcy5zY3JvbGxPYnNlcnZlciA9IGF3YWl0IHMuY3JlYXRlKC4xLCAhMSksXG4gICAgICAgICAgdGhpcy5zY3JvbGxPYnNlcnZlci5vYnNlcnZlKHRoaXMuZWwpLFxuICAgICAgICAgIHRoaXMuc2Nyb2xsT2JzZXJ2ZXIub25TZXBhcmF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuaGFuZGxlU2Nyb2xsKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5oYW5kbGVNb3VzZURvd24pLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5oYW5kbGVNb3VzZVVwKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5RG93biksIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSAhMSwgdGhpcy5jb25mLnBsYXlpbmcgJiYgdGhpcy5wYXVzZSgpXG4gICAgICAgICAgfSksIFxuICAgICAgICAgIHRoaXMuc2Nyb2xsT2JzZXJ2ZXIub25JbnRlcnNlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmhhbmRsZVNjcm9sbCksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuaGFuZGxlTW91c2VEb3duKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuaGFuZGxlTW91c2VVcCksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUtleURvd24pLCB0aGlzLmlzSW50ZXJzZWN0aW5nID0gITAsIHRoaXMuYWRkSXNMb2FkZWRDbGFzcygpLCB0aGlzLnBsYXkoKVxuICAgICAgICAgIH0pKi9cbiAgICAgIH1cbiAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsT2JzZXJ2ZXIgJiZcbiAgICAgICAgICAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5oYW5kbGVTY3JvbGwpLFxuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuaGFuZGxlTW91c2VEb3duKSxcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5oYW5kbGVNb3VzZVVwKSxcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlEb3duKSxcbiAgICAgICAgICB0aGlzLnNjcm9sbE9ic2VydmVyLmRpc2Nvbm5lY3QoKSksXG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5yZXNpemUpO1xuICAgICAgfVxuICAgICAgaW5pdE1hdGVyaWFsKCkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICAgIHVfdGltZTogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdV9zaGFkb3dfcG93ZXI6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgIHZhbHVlOiAxMCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB1X2Rhcmtlbl90b3A6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiID09PSB0aGlzLmVsLmRhdGFzZXQuanNEYXJrZW5Ub3AgPyAxIDogMCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB1X2FjdGl2ZV9jb2xvcnM6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmFjdGl2ZUNvbG9ycyxcbiAgICAgICAgICAgIHR5cGU6IFwidmVjNFwiLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHVfZ2xvYmFsOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICBub2lzZUZyZXE6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogW3RoaXMuZnJlcVgsIHRoaXMuZnJlcVldLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidmVjMlwiLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbm9pc2VTcGVlZDogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiA1ZS02LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiBcInN0cnVjdFwiLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHVfdmVydERlZm9ybTogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgaW5jbGluZTogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBNYXRoLnNpbih0aGlzLmFuZ2xlKSAvIE1hdGguY29zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgb2Zmc2V0VG9wOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IC0wLjUsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBvZmZzZXRCb3R0b206IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogLTAuNSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG5vaXNlRnJlcTogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbMywgNF0sXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ2ZWMyXCIsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBub2lzZUFtcDogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmFtcCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG5vaXNlU3BlZWQ6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMTAsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBub2lzZUZsb3c6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG5vaXNlU2VlZDogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNlZWQsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGU6IFwic3RydWN0XCIsXG4gICAgICAgICAgICBleGNsdWRlRnJvbTogXCJmcmFnbWVudFwiLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHVfYmFzZUNvbG9yOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zZWN0aW9uQ29sb3JzWzBdLFxuICAgICAgICAgICAgdHlwZTogXCJ2ZWMzXCIsXG4gICAgICAgICAgICBleGNsdWRlRnJvbTogXCJmcmFnbWVudFwiLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHVfd2F2ZUxheWVyczogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICAgICAgZXhjbHVkZUZyb206IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgZSA9IDE7IGUgPCB0aGlzLnNlY3Rpb25Db2xvcnMubGVuZ3RoOyBlICs9IDEpXG4gICAgICAgICAgdGhpcy51bmlmb3Jtcy51X3dhdmVMYXllcnMudmFsdWUucHVzaChcbiAgICAgICAgICAgIG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2VjdGlvbkNvbG9yc1tlXSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidmVjM1wiLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5vaXNlRnJlcTogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgICAgICAgICAgMiArIGUgLyB0aGlzLnNlY3Rpb25Db2xvcnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAzICsgZSAvIHRoaXMuc2VjdGlvbkNvbG9ycy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ2ZWMyXCIsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbm9pc2VTcGVlZDogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IDExICsgMC4zICogZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBub2lzZUZsb3c6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiA2LjUgKyAwLjMgKiBlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5vaXNlU2VlZDogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2VlZCArIDEwICogZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBub2lzZUZsb29yOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogMC4xLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5vaXNlQ2VpbDogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IDAuNjMgKyAwLjA3ICogZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJ1Y3RcIixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAodGhpcy52ZXJ0ZXhTaGFkZXIgPSBbXG4gICAgICAgICAgICB0aGlzLnNoYWRlckZpbGVzLm5vaXNlLFxuICAgICAgICAgICAgdGhpcy5zaGFkZXJGaWxlcy5ibGVuZCxcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyRmlsZXMudmVydGV4LFxuICAgICAgICAgIF0uam9pbihcIlxcblxcblwiKSksXG4gICAgICAgICAgbmV3IHRoaXMubWluaWdsLk1hdGVyaWFsKFxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgICB0aGlzLnNoYWRlckZpbGVzLmZyYWdtZW50LFxuICAgICAgICAgICAgdGhpcy51bmlmb3Jtc1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGluaXRNZXNoKCkge1xuICAgICAgICAodGhpcy5tYXRlcmlhbCA9IHRoaXMuaW5pdE1hdGVyaWFsKCkpLFxuICAgICAgICAgICh0aGlzLmdlb21ldHJ5ID0gbmV3IHRoaXMubWluaWdsLlBsYW5lR2VvbWV0cnkoKSksXG4gICAgICAgICAgKHRoaXMubWVzaCA9IG5ldyB0aGlzLm1pbmlnbC5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpKTtcbiAgICAgIH1cbiAgICAgIHNob3VsZFNraXBGcmFtZShlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgISF3aW5kb3cuZG9jdW1lbnQuaGlkZGVuIHx8XG4gICAgICAgICAgIXRoaXMuY29uZi5wbGF5aW5nIHx8XG4gICAgICAgICAgcGFyc2VJbnQoZSwgMTApICUgMiA9PSAwIHx8XG4gICAgICAgICAgdm9pZCAwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB1cGRhdGVGcmVxdWVuY3koZSkge1xuICAgICAgICAodGhpcy5mcmVxWCArPSBlKSwgKHRoaXMuZnJlcVkgKz0gZSk7XG4gICAgICB9XG4gICAgICB0b2dnbGVDb2xvcihpbmRleCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUNvbG9yc1tpbmRleF0gPSAwID09PSB0aGlzLmFjdGl2ZUNvbG9yc1tpbmRleF0gPyAxIDogMDtcbiAgICAgIH1cbiAgICAgIHNob3dHcmFkaWVudExlZ2VuZCgpIHtcbiAgICAgICAgdGhpcy53aWR0aCA+IHRoaXMubWluV2lkdGggJiZcbiAgICAgICAgICAoKHRoaXMuaXNHcmFkaWVudExlZ2VuZFZpc2libGUgPSAhMCksXG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiaXNHcmFkaWVudExlZ2VuZFZpc2libGVcIikpO1xuICAgICAgfVxuICAgICAgaGlkZUdyYWRpZW50TGVnZW5kKCkge1xuICAgICAgICAodGhpcy5pc0dyYWRpZW50TGVnZW5kVmlzaWJsZSA9ICExKSxcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJpc0dyYWRpZW50TGVnZW5kVmlzaWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdEdyYWRpZW50Q29sb3JzKCksXG4gICAgICAgICAgdGhpcy5pbml0TWVzaCgpLFxuICAgICAgICAgIHRoaXMucmVzaXplKCksXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSksXG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5yZXNpemUpO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICAqIFdhaXRpbmcgZm9yIHRoZSBjc3MgdmFyaWFibGVzIHRvIGJlY29tZSBhdmFpbGFibGUsIHVzdWFsbHkgb24gcGFnZSBsb2FkIGJlZm9yZSB3ZSBjYW4gY29udGludWUuXG4gICAgICAgKiBVc2luZyBkZWZhdWx0IGNvbG9ycyBhc3NpZ25lZCBiZWxvdyBpZiBubyB2YXJpYWJsZXMgaGF2ZSBiZWVuIGZvdW5kIGFmdGVyIG1heENzc1ZhclJldHJpZXNcbiAgICAgICAqL1xuICAgICAgd2FpdEZvckNzc1ZhcnMoKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLmNvbXB1dGVkQ2FudmFzU3R5bGUgJiZcbiAgICAgICAgICAtMSAhPT1cbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRDYW52YXNTdHlsZVxuICAgICAgICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZShcIi0tZ3JhZGllbnQtY29sb3ItMVwiKVxuICAgICAgICAgICAgICAuaW5kZXhPZihcIiNcIilcbiAgICAgICAgKVxuICAgICAgICAgIHRoaXMuaW5pdCgpLCB0aGlzLmFkZElzTG9hZGVkQ2xhc3MoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKCh0aGlzLmNzc1ZhclJldHJpZXMgKz0gMSksXG4gICAgICAgICAgICB0aGlzLmNzc1ZhclJldHJpZXMgPiB0aGlzLm1heENzc1ZhclJldHJpZXMpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAodGhpcy5zZWN0aW9uQ29sb3JzID0gWzE2NzExNjgwLCAxNjcxMTY4MCwgMTY3MTE5MzUsIDY1MjgwLCAyNTVdKSxcbiAgICAgICAgICAgICAgdm9pZCB0aGlzLmluaXQoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMud2FpdEZvckNzc1ZhcnMoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICAgKiBJbml0aWFsaXplcyB0aGUgZm91ciBzZWN0aW9uIGNvbG9ycyBieSByZXRyaWV2aW5nIHRoZW0gZnJvbSBjc3MgdmFyaWFibGVzLlxuICAgICAgICovXG4gICAgICBpbml0R3JhZGllbnRDb2xvcnMoKSB7XG4gICAgICAgIHRoaXMuc2VjdGlvbkNvbG9ycyA9IFtcbiAgICAgICAgICBcIi0tZ3JhZGllbnQtY29sb3ItMVwiLFxuICAgICAgICAgIFwiLS1ncmFkaWVudC1jb2xvci0yXCIsXG4gICAgICAgICAgXCItLWdyYWRpZW50LWNvbG9yLTNcIixcbiAgICAgICAgICBcIi0tZ3JhZGllbnQtY29sb3ItNFwiLFxuICAgICAgICBdXG4gICAgICAgICAgLm1hcCgoY3NzUHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgICAgICBsZXQgaGV4ID0gdGhpcy5jb21wdXRlZENhbnZhc1N0eWxlXG4gICAgICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKGNzc1Byb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgICAgIC8vQ2hlY2sgaWYgc2hvcnRoYW5kIGhleCB2YWx1ZSB3YXMgdXNlZCBhbmQgZG91YmxlIHRoZSBsZW5ndGggc28gdGhlIGNvbnZlcnNpb24gaW4gbm9ybWFsaXplQ29sb3Igd2lsbCB3b3JrLlxuICAgICAgICAgICAgaWYgKDQgPT09IGhleC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3QgaGV4VGVtcCA9IGhleFxuICAgICAgICAgICAgICAgIC5zdWJzdHIoMSlcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCJcIilcbiAgICAgICAgICAgICAgICAubWFwKChoZXhUZW1wKSA9PiBoZXhUZW1wICsgaGV4VGVtcClcbiAgICAgICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgaGV4ID0gYCMke2hleFRlbXB9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZXggJiYgYDB4JHtoZXguc3Vic3RyKDEpfWA7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgLm1hcChub3JtYWxpemVDb2xvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKkZpbmFsbHkgaW5pdGlhbGl6aW5nIHRoZSBHcmFkaWVudCBjbGFzcywgYXNzaWduaW5nIGEgY2FudmFzIHRvIGl0IGFuZCBjYWxsaW5nIEdyYWRpZW50LmNvbm5lY3QoKSB3aGljaCBpbml0aWFsaXplcyBldmVyeXRoaW5nLFxuICAgICAqIFVzZSBHcmFkaWVudC5wYXVzZSgpIGFuZCBHcmFkaWVudC5wbGF5KCkgZm9yIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogSGVyZSBhcmUgc29tZSBkZWZhdWx0IHByb3BlcnR5IHZhbHVlcyB5b3UgY2FuIGNoYW5nZSBhbnl0aW1lOlxuICAgICAqIEFtcGxpdHVkZTogICAgR3JhZGllbnQuYW1wID0gMFxuICAgICAqIENvbG9yczogICAgICAgR3JhZGllbnQuc2VjdGlvbkNvbG9ycyAoaWYgeW91IGNoYW5nZSBjb2xvcnMsIHVzZSBub3JtYWxpemVDb2xvcigjaGV4VmFsdWUpKSBiZWZvcmUgeW91IGFzc2lnbiBpdC5cbiAgICAgKlxuICAgICAqXG4gICAgICogVXNlZnVsIGZ1bmN0aW9uc1xuICAgICAqIEdyYWRpZW50LnRvZ2dsZUNvbG9yKGluZGV4KVxuICAgICAqIEdyYWRpZW50LnVwZGF0ZUZyZXF1ZW5jeShmcmVxKVxuICAgICAqL1xuICAgIHZhciBncmFkaWVudCA9IG5ldyBHcmFkaWVudCgpO1xuICAgIGdyYWRpZW50LmluaXRHcmFkaWVudChcIiNncmFkaWVudC1jYW52YXNcIik7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8Y2FudmFzIGlkPVwiZ3JhZGllbnQtY2FudmFzXCIgc3R5bGU9XCJ3aWR0aDoxMDB2dztoZWlnaHQ6MTAwdmhcIj48L2NhbnZhcz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RyaXBlO1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsIlN0cmlwZSIsIm5vcm1hbGl6ZUNvbG9yIiwiaGV4Q29kZSIsInJlZHVjZSIsInQiLCJuIiwiT2JqZWN0IiwiYXNzaWduIiwiTWluaUdsIiwic2V0U2l6ZSIsImUiLCJ3aWR0aCIsImhlaWdodCIsImNhbnZhcyIsImdsIiwidmlld3BvcnQiLCJjb21tb25Vbmlmb3JtcyIsInJlc29sdXRpb24iLCJ2YWx1ZSIsImFzcGVjdFJhdGlvIiwiZGVidWciLCJzZXRPcnRob2dyYXBoaWNDYW1lcmEiLCJpIiwicyIsInByb2plY3Rpb25NYXRyaXgiLCJyZW5kZXIiLCJjbGVhckNvbG9yIiwiY2xlYXJEZXB0aCIsIm1lc2hlcyIsImZvckVhY2giLCJkcmF3IiwiY29uc3RydWN0b3IiLCJfbWluaUdsIiwiZGVidWdfb3V0cHV0IiwiZG9jdW1lbnQiLCJsb2NhdGlvbiIsInNlYXJjaCIsInRvTG93ZXJDYXNlIiwiaW5kZXhPZiIsImdldENvbnRleHQiLCJhbnRpYWxpYXMiLCJjb250ZXh0IiwibGFzdERlYnVnTXNnIiwiRGF0ZSIsImNvbnNvbGUiLCJsb2ciLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJBcnJheSIsIk1hdGgiLCJtYXgiLCJsZW5ndGgiLCJqb2luIiwiZnJvbSIsImFyZ3VtZW50cyIsInNsaWNlIiwiZGVmaW5lUHJvcGVydGllcyIsIk1hdGVyaWFsIiwiZW51bWVyYWJsZSIsImF0dGFjaFVuaWZvcm1zIiwibmFtZSIsInVuaWZvcm1zIiwibWF0ZXJpYWwiLCJlbnRyaWVzIiwidW5pZm9ybSIsInR5cGUiLCJ1bmlmb3JtSW5zdGFuY2VzIiwicHVzaCIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInByb2dyYW0iLCJ2ZXJ0ZXhTaGFkZXJzIiwiZnJhZ21lbnRzIiwiZ2V0U2hhZGVyQnlUeXBlIiwic291cmNlIiwic2hhZGVyIiwiY3JlYXRlU2hhZGVyIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiZXJyb3IiLCJnZXRTaGFkZXJJbmZvTG9nIiwiZ2V0VW5pZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25zIiwibWFwIiwiZ2V0RGVjbGFyYXRpb24iLCJwcmVmaXgiLCJ2ZXJ0ZXhTb3VyY2UiLCJTb3VyY2UiLCJ2ZXJ0ZXhTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiZnJhZ21lbnRTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJjcmVhdGVQcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJnZXRQcm9ncmFtSW5mb0xvZyIsInVzZVByb2dyYW0iLCJVbmlmb3JtIiwidXBkYXRlIiwidHlwZUZuIiwidHJhbnNwb3NlIiwiZXhjbHVkZUZyb20iLCJuYW1lX25vX3ByZWZpeCIsInJlcGxhY2UiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsImZsb2F0IiwiaW50IiwidmVjMiIsInZlYzMiLCJ2ZWM0IiwibWF0NCIsIlBsYW5lR2VvbWV0cnkiLCJzZXRUb3BvbG9neSIsInhTZWdDb3VudCIsInlTZWdDb3VudCIsInZlcnRleENvdW50IiwicXVhZENvdW50IiwiYXR0cmlidXRlcyIsInV2IiwidmFsdWVzIiwiRmxvYXQzMkFycmF5IiwidXZOb3JtIiwiaW5kZXgiLCJVaW50MTZBcnJheSIsIm9yaWVudGF0aW9uIiwiZ2VvbWV0cnkiLCJwb3NpdGlvbiIsIm8iLCJyIiwic2VnbWVudF93aWR0aCIsInNlZ21lbnRfaGVpZ2h0IiwieUluZGV4IiwieEluZGV4IiwibCIsImNyZWF0ZUJ1ZmZlciIsIkF0dHJpYnV0ZSIsInRhcmdldCIsIkFSUkFZX0JVRkZFUiIsInNpemUiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsIlVOU0lHTkVEX1NIT1JUIiwiTWVzaCIsImF0dHJpYnV0ZUluc3RhbmNlcyIsImF0dHJpYnV0ZSIsInVzZSIsImRyYXdFbGVtZW50cyIsIndpcmVmcmFtZSIsIkxJTkVTIiwiVFJJQU5HTEVTIiwicmVtb3ZlIiwiZmlsdGVyIiwibWVzaCIsImF0dGFjaCIsImJpbmRCdWZmZXIiLCJidWZmZXIiLCJidWZmZXJEYXRhIiwiU1RBVElDX0RSQVciLCJnZXRBdHRyaWJMb2NhdGlvbiIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIm5vcm1hbGl6ZWQiLCJGTE9BVCIsImEiLCJtb2RlbFZpZXdNYXRyaXgiLCJvYmplY3QiLCJwcm9wZXJ0eU5hbWUiLCJ2YWwiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiR3JhZGllbnQiLCJjb25uZWN0Iiwic2hhZGVyRmlsZXMiLCJ2ZXJ0ZXgiLCJub2lzZSIsImJsZW5kIiwiZnJhZ21lbnQiLCJjb25mIiwicHJlc2V0TmFtZSIsImRlbnNpdHkiLCJ6b29tIiwicm90YXRpb24iLCJwbGF5aW5nIiwicXVlcnlTZWxlY3RvckFsbCIsIm1pbmlnbCIsImVsIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY29tcHV0ZWRDYW52YXNTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJ3YWl0Rm9yQ3NzVmFycyIsImRpc2Nvbm5lY3QiLCJzY3JvbGxPYnNlcnZlciIsIndpbmRvdyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVTY3JvbGwiLCJoYW5kbGVNb3VzZURvd24iLCJoYW5kbGVNb3VzZVVwIiwiaGFuZGxlS2V5RG93biIsInJlc2l6ZSIsImluaXRNYXRlcmlhbCIsInVfdGltZSIsInVfc2hhZG93X3Bvd2VyIiwidV9kYXJrZW5fdG9wIiwiZGF0YXNldCIsImpzRGFya2VuVG9wIiwidV9hY3RpdmVfY29sb3JzIiwiYWN0aXZlQ29sb3JzIiwidV9nbG9iYWwiLCJub2lzZUZyZXEiLCJmcmVxWCIsImZyZXFZIiwibm9pc2VTcGVlZCIsInVfdmVydERlZm9ybSIsImluY2xpbmUiLCJzaW4iLCJhbmdsZSIsImNvcyIsIm9mZnNldFRvcCIsIm9mZnNldEJvdHRvbSIsIm5vaXNlQW1wIiwiYW1wIiwibm9pc2VGbG93Iiwibm9pc2VTZWVkIiwic2VlZCIsInVfYmFzZUNvbG9yIiwic2VjdGlvbkNvbG9ycyIsInVfd2F2ZUxheWVycyIsImNvbG9yIiwibm9pc2VGbG9vciIsIm5vaXNlQ2VpbCIsImluaXRNZXNoIiwic2hvdWxkU2tpcEZyYW1lIiwiaGlkZGVuIiwicGFyc2VJbnQiLCJ1cGRhdGVGcmVxdWVuY3kiLCJ0b2dnbGVDb2xvciIsInNob3dHcmFkaWVudExlZ2VuZCIsIm1pbldpZHRoIiwiaXNHcmFkaWVudExlZ2VuZFZpc2libGUiLCJib2R5IiwiY2xhc3NMaXN0IiwiYWRkIiwiaGlkZUdyYWRpZW50TGVnZW5kIiwiaW5pdCIsImluaXRHcmFkaWVudENvbG9ycyIsImFuaW1hdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImFkZElzTG9hZGVkQ2xhc3MiLCJjc3NWYXJSZXRyaWVzIiwibWF4Q3NzVmFyUmV0cmllcyIsImNzc1Byb3BlcnR5TmFtZSIsImhleCIsInRyaW0iLCJoZXhUZW1wIiwic3Vic3RyIiwic3BsaXQiLCJCb29sZWFuIiwiY2xlYXJUaW1lb3V0Iiwic2Nyb2xsaW5nVGltZW91dCIsInNldFRpbWVvdXQiLCJoYW5kbGVTY3JvbGxFbmQiLCJzY3JvbGxpbmdSZWZyZXNoRGVsYXkiLCJpc1Njcm9sbGluZyIsInBhdXNlIiwiaXNJbnRlcnNlY3RpbmciLCJwbGF5IiwiaW5uZXJXaWR0aCIsImNlaWwiLCJpc01ldGFLZXkiLCJtZXRhS2V5IiwiaXNNb3VzZURvd24iLCJtaW4iLCJsYXN0IiwiaXNTdGF0aWMiLCJpc0xvYWRlZENsYXNzIiwicGFyZW50RWxlbWVudCIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsImdyYWRpZW50IiwiaW5pdEdyYWRpZW50IiwiZGl2IiwiaWQiLCJzdHlsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/Stripe.js\n"));

/***/ })

});