"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/Stripe.js":
/*!***********************!*\
  !*** ./app/Stripe.js ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction Stripe() {\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        /*\n     *   Stripe WebGl Gradient Animation by Stripe.com\n     *   ScrollObserver functionality to disable animation when not scrolled into view has been disabled and\n     *   commented out for now.\n     */ //Converting colors to proper format\n        function normalizeColor(hexCode) {\n            return [\n                (hexCode >> 16 & 255) / 255,\n                (hexCode >> 8 & 255) / 255,\n                (255 & hexCode) / 255\n            ];\n        }\n        [\n            \"SCREEN\",\n            \"LINEAR_LIGHT\"\n        ].reduce((hexCode, t, n)=>Object.assign(hexCode, {\n                [t]: n\n            }), {});\n        //Essential functionality of WebGl\n        //t = width\n        //n = height\n        class MiniGl {\n            setSize() {\n                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 640, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 480;\n                this.width = e, this.height = t, this.canvas.width = e, this.canvas.height = t, this.gl.viewport(0, 0, e, t), this.commonUniforms.resolution.value = [\n                    e,\n                    t\n                ], this.commonUniforms.aspectRatio.value = e / t, this.debug(\"MiniGL.setSize\", {\n                    width: e,\n                    height: t\n                });\n            }\n            //left, right, top, bottom, near, far\n            setOrthographicCamera() {\n                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -2e3, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2e3;\n                this.commonUniforms.projectionMatrix.value = [\n                    2 / this.width,\n                    0,\n                    0,\n                    0,\n                    0,\n                    2 / this.height,\n                    0,\n                    0,\n                    0,\n                    0,\n                    2 / (i - s),\n                    0,\n                    e,\n                    t,\n                    n,\n                    1\n                ], this.debug(\"setOrthographicCamera\", this.commonUniforms.projectionMatrix.value);\n            }\n            render() {\n                this.gl.clearColor(0, 0, 0, 0), this.gl.clearDepth(1), this.meshes.forEach((e)=>e.draw());\n            }\n            constructor(canvas, width, height, debug = false){\n                const _miniGl = this, debug_output = -1 !== document.location.search.toLowerCase().indexOf(\"debug=webgl\");\n                _miniGl.canvas = canvas, _miniGl.gl = _miniGl.canvas.getContext(\"webgl\", {\n                    antialias: true\n                }), _miniGl.meshes = [];\n                const context = _miniGl.gl;\n                width && height && this.setSize(width, height), _miniGl.lastDebugMsg, _miniGl.debug = debug && debug_output ? function(e) {\n                    const t = new Date();\n                    t - _miniGl.lastDebugMsg > 1e3 && console.log(\"---\"), console.log(t.toLocaleTimeString() + Array(Math.max(0, 32 - e.length)).join(\" \") + e + \": \", ...Array.from(arguments).slice(1)), _miniGl.lastDebugMsg = t;\n                } : ()=>{}, Object.defineProperties(_miniGl, {\n                    Material: {\n                        enumerable: false,\n                        value: class {\n                            //t = uniform\n                            attachUniforms(name, uniforms) {\n                                //n  = material\n                                const material = this;\n                                void 0 === name ? Object.entries(uniforms).forEach((param)=>{\n                                    let [name, uniform] = param;\n                                    material.attachUniforms(name, uniform);\n                                }) : \"array\" == uniforms.type ? uniforms.value.forEach((uniform, i)=>material.attachUniforms(\"\".concat(name, \"[\").concat(i, \"]\"), uniform)) : \"struct\" == uniforms.type ? Object.entries(uniforms.value).forEach((param)=>{\n                                    let [uniform, i] = param;\n                                    return material.attachUniforms(\"\".concat(name, \".\").concat(uniform), i);\n                                }) : (_miniGl.debug(\"Material.attachUniforms\", {\n                                    name: name,\n                                    uniform: uniforms\n                                }), material.uniformInstances.push({\n                                    uniform: uniforms,\n                                    location: context.getUniformLocation(material.program, name)\n                                }));\n                            }\n                            constructor(vertexShaders, fragments, uniforms = {}){\n                                const material = this;\n                                function getShaderByType(type, source) {\n                                    const shader = context.createShader(type);\n                                    return context.shaderSource(shader, source), context.compileShader(shader), context.getShaderParameter(shader, context.COMPILE_STATUS) || console.error(context.getShaderInfoLog(shader)), _miniGl.debug(\"Material.compileShaderSource\", {\n                                        source: source\n                                    }), shader;\n                                }\n                                function getUniformVariableDeclarations(uniforms, type) {\n                                    return Object.entries(uniforms).map((param)=>{\n                                        let [uniform, value] = param;\n                                        return value.getDeclaration(uniform, type);\n                                    }).join(\"\\n\");\n                                }\n                                material.uniforms = uniforms, material.uniformInstances = [];\n                                const prefix = \"\\n              precision highp float;\\n            \";\n                                material.vertexSource = \"\\n              \".concat(prefix, \"\\n              attribute vec4 position;\\n              attribute vec2 uv;\\n              attribute vec2 uvNorm;\\n              \").concat(getUniformVariableDeclarations(_miniGl.commonUniforms, \"vertex\"), \"\\n              \").concat(getUniformVariableDeclarations(uniforms, \"vertex\"), \"\\n              \").concat(vertexShaders, \"\\n            \"), material.Source = \"\\n              \".concat(prefix, \"\\n              \").concat(getUniformVariableDeclarations(_miniGl.commonUniforms, \"fragment\"), \"\\n              \").concat(getUniformVariableDeclarations(uniforms, \"fragment\"), \"\\n              \").concat(fragments, \"\\n            \"), material.vertexShader = getShaderByType(context.VERTEX_SHADER, material.vertexSource), material.fragmentShader = getShaderByType(context.FRAGMENT_SHADER, material.Source), material.program = context.createProgram(), context.attachShader(material.program, material.vertexShader), context.attachShader(material.program, material.fragmentShader), context.linkProgram(material.program), context.getProgramParameter(material.program, context.LINK_STATUS) || console.error(context.getProgramInfoLog(material.program)), context.useProgram(material.program), material.attachUniforms(void 0, _miniGl.commonUniforms), material.attachUniforms(void 0, material.uniforms);\n                            }\n                        }\n                    },\n                    Uniform: {\n                        enumerable: !1,\n                        value: class {\n                            update(value) {\n                                void 0 !== this.value && context[\"uniform\".concat(this.typeFn)](value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.transpose : this.value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.value : null);\n                            }\n                            //e - name\n                            //t - type\n                            //n - length\n                            getDeclaration(name, type, length) {\n                                const uniform = this;\n                                if (uniform.excludeFrom !== type) {\n                                    var _uniform_value_;\n                                    if (\"array\" === uniform.type) return ((_uniform_value_ = uniform.value[0]) === null || _uniform_value_ === void 0 ? void 0 : _uniform_value_.getDeclaration(name, type, uniform.value.length)) + \"\\nconst int \".concat(name, \"_length = \").concat(uniform.value.length, \";\");\n                                    if (\"struct\" === uniform.type) {\n                                        let name_no_prefix = name.replace(\"u_\", \"\");\n                                        return name_no_prefix = name_no_prefix.charAt(0).toUpperCase() + name_no_prefix.slice(1), \"uniform struct \".concat(name_no_prefix, \" \\n                                  {\\n\") + Object.entries(uniform.value).map((param)=>{\n                                            let [name, uniform] = param;\n                                            return uniform.getDeclaration(name, type).replace(/^uniform/, \"\");\n                                        }).join(\"\") + \"\\n} \".concat(name).concat(length > 0 ? \"[\".concat(length, \"]\") : \"\", \";\");\n                                    }\n                                    return \"uniform \".concat(uniform.type, \" \").concat(name).concat(length > 0 ? \"[\".concat(length, \"]\") : \"\", \";\");\n                                }\n                            }\n                            constructor(e){\n                                this.type = \"float\", Object.assign(this, e);\n                                this.typeFn = ({\n                                    float: \"1f\",\n                                    int: \"1i\",\n                                    vec2: \"2fv\",\n                                    vec3: \"3fv\",\n                                    vec4: \"4fv\",\n                                    mat4: \"Matrix4fv\"\n                                })[this.type] || \"1f\", this.update();\n                            }\n                        }\n                    },\n                    PlaneGeometry: {\n                        enumerable: !1,\n                        value: class {\n                            setTopology() {\n                                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n                                const n = this;\n                                n.xSegCount = e, n.ySegCount = t, n.vertexCount = (n.xSegCount + 1) * (n.ySegCount + 1), n.quadCount = n.xSegCount * n.ySegCount * 2, n.attributes.uv.values = new Float32Array(2 * n.vertexCount), n.attributes.uvNorm.values = new Float32Array(2 * n.vertexCount), n.attributes.index.values = new Uint16Array(3 * n.quadCount);\n                                for(let e = 0; e <= n.ySegCount; e++)for(let t = 0; t <= n.xSegCount; t++){\n                                    const i = e * (n.xSegCount + 1) + t;\n                                    if (n.attributes.uv.values[2 * i] = t / n.xSegCount, n.attributes.uv.values[2 * i + 1] = 1 - e / n.ySegCount, n.attributes.uvNorm.values[2 * i] = t / n.xSegCount * 2 - 1, n.attributes.uvNorm.values[2 * i + 1] = 1 - e / n.ySegCount * 2, t < n.xSegCount && e < n.ySegCount) {\n                                        const s = e * n.xSegCount + t;\n                                        n.attributes.index.values[6 * s] = i, n.attributes.index.values[6 * s + 1] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 2] = i + 1, n.attributes.index.values[6 * s + 3] = i + 1, n.attributes.index.values[6 * s + 4] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 5] = i + 2 + n.xSegCount;\n                                    }\n                                }\n                                n.attributes.uv.update(), n.attributes.uvNorm.update(), n.attributes.index.update(), _miniGl.debug(\"Geometry.setTopology\", {\n                                    uv: n.attributes.uv,\n                                    uvNorm: n.attributes.uvNorm,\n                                    index: n.attributes.index\n                                });\n                            }\n                            setSize() {\n                                let width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, orientation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"xz\";\n                                const geometry = this;\n                                geometry.width = width, geometry.height = height, geometry.orientation = orientation, geometry.attributes.position.values && geometry.attributes.position.values.length === 3 * geometry.vertexCount || (geometry.attributes.position.values = new Float32Array(3 * geometry.vertexCount));\n                                const o = width / -2, r = height / -2, segment_width = width / geometry.xSegCount, segment_height = height / geometry.ySegCount;\n                                for(let yIndex = 0; yIndex <= geometry.ySegCount; yIndex++){\n                                    const t = r + yIndex * segment_height;\n                                    for(let xIndex = 0; xIndex <= geometry.xSegCount; xIndex++){\n                                        const r = o + xIndex * segment_width, l = yIndex * (geometry.xSegCount + 1) + xIndex;\n                                        geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[0])] = r, geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[1])] = -t;\n                                    }\n                                }\n                                geometry.attributes.position.update(), _miniGl.debug(\"Geometry.setSize\", {\n                                    position: geometry.attributes.position\n                                });\n                            }\n                            constructor(width, height, n, i, orientation){\n                                context.createBuffer(), this.attributes = {\n                                    position: new _miniGl.Attribute({\n                                        target: context.ARRAY_BUFFER,\n                                        size: 3\n                                    }),\n                                    uv: new _miniGl.Attribute({\n                                        target: context.ARRAY_BUFFER,\n                                        size: 2\n                                    }),\n                                    uvNorm: new _miniGl.Attribute({\n                                        target: context.ARRAY_BUFFER,\n                                        size: 2\n                                    }),\n                                    index: new _miniGl.Attribute({\n                                        target: context.ELEMENT_ARRAY_BUFFER,\n                                        size: 3,\n                                        type: context.UNSIGNED_SHORT\n                                    })\n                                }, this.setTopology(n, i), this.setSize(width, height, orientation);\n                            }\n                        }\n                    },\n                    Mesh: {\n                        enumerable: !1,\n                        value: class {\n                            draw() {\n                                context.useProgram(this.material.program), this.material.uniformInstances.forEach((param)=>{\n                                    let { uniform: e, location: t } = param;\n                                    return e.update(t);\n                                }), this.attributeInstances.forEach((param)=>{\n                                    let { attribute: e, location: t } = param;\n                                    return e.use(t);\n                                }), context.drawElements(this.wireframe ? context.LINES : context.TRIANGLES, this.geometry.attributes.index.values.length, context.UNSIGNED_SHORT, 0);\n                            }\n                            remove() {\n                                _miniGl.meshes = _miniGl.meshes.filter((e)=>e != this);\n                            }\n                            constructor(geometry, material){\n                                const mesh = this;\n                                mesh.geometry = geometry, mesh.material = material, mesh.wireframe = !1, mesh.attributeInstances = [], Object.entries(mesh.geometry.attributes).forEach((param)=>{\n                                    let [e, attribute] = param;\n                                    mesh.attributeInstances.push({\n                                        attribute: attribute,\n                                        location: attribute.attach(e, mesh.material.program)\n                                    });\n                                }), _miniGl.meshes.push(mesh), _miniGl.debug(\"Mesh.constructor\", {\n                                    mesh: mesh\n                                });\n                            }\n                        }\n                    },\n                    Attribute: {\n                        enumerable: !1,\n                        value: class {\n                            update() {\n                                void 0 !== this.values && (context.bindBuffer(this.target, this.buffer), context.bufferData(this.target, this.values, context.STATIC_DRAW));\n                            }\n                            attach(e, t) {\n                                const n = context.getAttribLocation(t, e);\n                                return this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(n), context.vertexAttribPointer(n, this.size, this.type, this.normalized, 0, 0)), n;\n                            }\n                            use(e) {\n                                context.bindBuffer(this.target, this.buffer), this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(e), context.vertexAttribPointer(e, this.size, this.type, this.normalized, 0, 0));\n                            }\n                            constructor(e){\n                                this.type = context.FLOAT, this.normalized = !1, this.buffer = context.createBuffer(), Object.assign(this, e), this.update();\n                            }\n                        }\n                    }\n                });\n                const a = [\n                    1,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n                _miniGl.commonUniforms = {\n                    projectionMatrix: new _miniGl.Uniform({\n                        type: \"mat4\",\n                        value: a\n                    }),\n                    modelViewMatrix: new _miniGl.Uniform({\n                        type: \"mat4\",\n                        value: a\n                    }),\n                    resolution: new _miniGl.Uniform({\n                        type: \"vec2\",\n                        value: [\n                            1,\n                            1\n                        ]\n                    }),\n                    aspectRatio: new _miniGl.Uniform({\n                        type: \"float\",\n                        value: 1\n                    })\n                };\n            }\n        }\n        //Sets initial properties\n        function e(object, propertyName, val) {\n            return propertyName in object ? Object.defineProperty(object, propertyName, {\n                value: val,\n                enumerable: !0,\n                configurable: !0,\n                writable: !0\n            }) : object[propertyName] = val, object;\n        }\n        //Gradient object\n        class Gradient {\n            async connect() {\n                this.shaderFiles = {\n                    vertex: \"varying vec3 v_color;\\n\\nvoid main() {\\n  float time = u_time * u_global.noiseSpeed;\\n\\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\\n\\n  vec2 st = 1. - uvNorm.xy;\\n\\n  //\\n  // Tilting the plane\\n  //\\n\\n  // Front-to-back tilt\\n  float tilt = resolution.y / 2.0 * uvNorm.y;\\n\\n  // Left-to-right angle\\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\\n\\n  // Up-down shift to offset incline\\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\\n\\n  //\\n  // Vertex noise\\n  //\\n\\n  float noise = snoise(vec3(\\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\\n  )) * u_vertDeform.noiseAmp;\\n\\n  // Fade noise to zero at edges\\n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\\n\\n  // Clamp to 0\\n  noise = max(0.0, noise);\\n\\n  vec3 pos = vec3(\\n    position.x,\\n    position.y + tilt + incline + noise - offset,\\n    position.z\\n  );\\n\\n  //\\n  // Vertex color, to be passed to fragment shader\\n  //\\n\\n  if (u_active_colors[0] == 1.) {\\n    v_color = u_baseColor;\\n  }\\n\\n  for (int i = 0; i < u_waveLayers_length; i++) {\\n    if (u_active_colors[i + 1] == 1.) {\\n      WaveLayers layer = u_waveLayers[i];\\n\\n      float noise = smoothstep(\\n        layer.noiseFloor,\\n        layer.noiseCeil,\\n        snoise(vec3(\\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\\n          noiseCoord.y * layer.noiseFreq.y,\\n          time * layer.noiseSpeed + layer.noiseSeed\\n        )) / 2.0 + 0.5\\n      );\\n\\n      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));\\n    }\\n  }\\n\\n  //\\n  // Finish\\n  //\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n}\",\n                    noise: \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\",\n                    blend: \"//\\n// https://github.com/jamieowen/glsl-blend\\n//\\n\\n// Normal\\n\\nvec3 blendNormal(vec3 base, vec3 blend) {\\n\treturn blend;\\n}\\n\\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Screen\\n\\nfloat blendScreen(float base, float blend) {\\n\treturn 1.0-((1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend) {\\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Multiply\\n\\nvec3 blendMultiply(vec3 base, vec3 blend) {\\n\treturn base*blend;\\n}\\n\\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Overlay\\n\\nfloat blendOverlay(float base, float blend) {\\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend) {\\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Hard light\\n\\nvec3 blendHardLight(vec3 base, vec3 blend) {\\n\treturn blendOverlay(blend,base);\\n}\\n\\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Soft light\\n\\nfloat blendSoftLight(float base, float blend) {\\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend) {\\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color dodge\\n\\nfloat blendColorDodge(float base, float blend) {\\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend) {\\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color burn\\n\\nfloat blendColorBurn(float base, float blend) {\\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend) {\\n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Vivid Light\\n\\nfloat blendVividLight(float base, float blend) {\\n\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend) {\\n\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Lighten\\n\\nfloat blendLighten(float base, float blend) {\\n\treturn max(blend,base);\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend) {\\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear burn\\n\\nfloat blendLinearBurn(float base, float blend) {\\n\t// Note : Same implementation as BlendSubtractf\\n\treturn max(base+blend-1.0,0.0);\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\\n\t// Note : Same implementation as BlendSubtract\\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear dodge\\n\\nfloat blendLinearDodge(float base, float blend) {\\n\t// Note : Same implementation as BlendAddf\\n\treturn min(base+blend,1.0);\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\\n\t// Note : Same implementation as BlendAdd\\n\treturn min(base+blend,vec3(1.0));\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear light\\n\\nfloat blendLinearLight(float base, float blend) {\\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend) {\\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\",\n                    fragment: \"varying vec3 v_color;\\n\\nvoid main() {\\n  vec3 color = v_color;\\n  if (u_darken_top == 1.0) {\\n    vec2 st = gl_FragCoord.xy/resolution.xy;\\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\\n  }\\n  gl_FragColor = vec4(color, 1.0);\\n}\"\n                }, this.conf = {\n                    presetName: \"\",\n                    wireframe: false,\n                    density: [\n                        0.06,\n                        0.16\n                    ],\n                    zoom: 1,\n                    rotation: 0,\n                    playing: true\n                }, document.querySelectorAll(\"canvas\").length < 1 ? console.log(\"DID NOT LOAD HERO STRIPE CANVAS\") : (this.minigl = new MiniGl(this.el, null, null, !0), requestAnimationFrame(()=>{\n                    this.el && (this.computedCanvasStyle = getComputedStyle(this.el), this.waitForCssVars());\n                }));\n            /*\n          this.scrollObserver = await s.create(.1, !1),\n          this.scrollObserver.observe(this.el),\n          this.scrollObserver.onSeparate(() => {\n              window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !1, this.conf.playing && this.pause()\n          }), \n          this.scrollObserver.onIntersect(() => {\n              window.addEventListener(\"scroll\", this.handleScroll), window.addEventListener(\"mousedown\", this.handleMouseDown), window.addEventListener(\"mouseup\", this.handleMouseUp), window.addEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !0, this.addIsLoadedClass(), this.play()\n          })*/ }\n            disconnect() {\n                this.scrollObserver && (window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.scrollObserver.disconnect()), window.removeEventListener(\"resize\", this.resize);\n            }\n            initMaterial() {\n                this.uniforms = {\n                    u_time: new this.minigl.Uniform({\n                        value: 0\n                    }),\n                    u_shadow_power: new this.minigl.Uniform({\n                        value: 10\n                    }),\n                    u_darken_top: new this.minigl.Uniform({\n                        value: \"\" === this.el.dataset.jsDarkenTop ? 1 : 0\n                    }),\n                    u_active_colors: new this.minigl.Uniform({\n                        value: this.activeColors,\n                        type: \"vec4\"\n                    }),\n                    u_global: new this.minigl.Uniform({\n                        value: {\n                            noiseFreq: new this.minigl.Uniform({\n                                value: [\n                                    this.freqX,\n                                    this.freqY\n                                ],\n                                type: \"vec2\"\n                            }),\n                            noiseSpeed: new this.minigl.Uniform({\n                                value: 5e-6\n                            })\n                        },\n                        type: \"struct\"\n                    }),\n                    u_vertDeform: new this.minigl.Uniform({\n                        value: {\n                            incline: new this.minigl.Uniform({\n                                value: Math.sin(this.angle) / Math.cos(this.angle)\n                            }),\n                            offsetTop: new this.minigl.Uniform({\n                                value: -0.5\n                            }),\n                            offsetBottom: new this.minigl.Uniform({\n                                value: -0.5\n                            }),\n                            noiseFreq: new this.minigl.Uniform({\n                                value: [\n                                    3,\n                                    4\n                                ],\n                                type: \"vec2\"\n                            }),\n                            noiseAmp: new this.minigl.Uniform({\n                                value: this.amp\n                            }),\n                            noiseSpeed: new this.minigl.Uniform({\n                                value: 10\n                            }),\n                            noiseFlow: new this.minigl.Uniform({\n                                value: 3\n                            }),\n                            noiseSeed: new this.minigl.Uniform({\n                                value: this.seed\n                            })\n                        },\n                        type: \"struct\",\n                        excludeFrom: \"fragment\"\n                    }),\n                    u_baseColor: new this.minigl.Uniform({\n                        value: this.sectionColors[0],\n                        type: \"vec3\",\n                        excludeFrom: \"fragment\"\n                    }),\n                    u_waveLayers: new this.minigl.Uniform({\n                        value: [],\n                        excludeFrom: \"fragment\",\n                        type: \"array\"\n                    })\n                };\n                for(let e = 1; e < this.sectionColors.length; e += 1)this.uniforms.u_waveLayers.value.push(new this.minigl.Uniform({\n                    value: {\n                        color: new this.minigl.Uniform({\n                            value: this.sectionColors[e],\n                            type: \"vec3\"\n                        }),\n                        noiseFreq: new this.minigl.Uniform({\n                            value: [\n                                2 + e / this.sectionColors.length,\n                                3 + e / this.sectionColors.length\n                            ],\n                            type: \"vec2\"\n                        }),\n                        noiseSpeed: new this.minigl.Uniform({\n                            value: 11 + 0.3 * e\n                        }),\n                        noiseFlow: new this.minigl.Uniform({\n                            value: 6.5 + 0.3 * e\n                        }),\n                        noiseSeed: new this.minigl.Uniform({\n                            value: this.seed + 10 * e\n                        }),\n                        noiseFloor: new this.minigl.Uniform({\n                            value: 0.1\n                        }),\n                        noiseCeil: new this.minigl.Uniform({\n                            value: 0.63 + 0.07 * e\n                        })\n                    },\n                    type: \"struct\"\n                }));\n                return this.vertexShader = [\n                    this.shaderFiles.noise,\n                    this.shaderFiles.blend,\n                    this.shaderFiles.vertex\n                ].join(\"\\n\\n\"), new this.minigl.Material(this.vertexShader, this.shaderFiles.fragment, this.uniforms);\n            }\n            initMesh() {\n                this.material = this.initMaterial(), this.geometry = new this.minigl.PlaneGeometry(), this.mesh = new this.minigl.Mesh(this.geometry, this.material);\n            }\n            shouldSkipFrame(e) {\n                return !!window.document.hidden || !this.conf.playing || parseInt(e, 10) % 2 == 0 || void 0;\n            }\n            updateFrequency(e) {\n                this.freqX += e, this.freqY += e;\n            }\n            toggleColor(index) {\n                this.activeColors[index] = 0 === this.activeColors[index] ? 1 : 0;\n            }\n            showGradientLegend() {\n                this.width > this.minWidth && (this.isGradientLegendVisible = !0, document.body.classList.add(\"isGradientLegendVisible\"));\n            }\n            hideGradientLegend() {\n                this.isGradientLegendVisible = !1, document.body.classList.remove(\"isGradientLegendVisible\");\n            }\n            init() {\n                this.initGradientColors(), this.initMesh(), this.resize(), requestAnimationFrame(this.animate), window.addEventListener(\"resize\", this.resize);\n            }\n            /*\n       * Waiting for the css variables to become available, usually on page load before we can continue.\n       * Using default colors assigned below if no variables have been found after maxCssVarRetries\n       */ waitForCssVars() {\n                if (this.computedCanvasStyle && -1 !== this.computedCanvasStyle.getPropertyValue(\"--gradient-color-1\").indexOf(\"#\")) this.init(), this.addIsLoadedClass();\n                else {\n                    if (this.cssVarRetries += 1, this.cssVarRetries > this.maxCssVarRetries) {\n                        return this.sectionColors = [\n                            16711680,\n                            16711680,\n                            16711935,\n                            65280,\n                            255\n                        ], void this.init();\n                    }\n                    requestAnimationFrame(()=>this.waitForCssVars());\n                }\n            }\n            /*\n       * Initializes the four section colors by retrieving them from css variables.\n       */ initGradientColors() {\n                this.sectionColors = [\n                    \"--gradient-color-1\",\n                    \"--gradient-color-2\",\n                    \"--gradient-color-3\",\n                    \"--gradient-color-4\"\n                ].map((cssPropertyName)=>{\n                    let hex = this.computedCanvasStyle.getPropertyValue(cssPropertyName).trim();\n                    //Check if shorthand hex value was used and double the length so the conversion in normalizeColor will work.\n                    if (4 === hex.length) {\n                        const hexTemp = hex.substr(1).split(\"\").map((hexTemp)=>hexTemp + hexTemp).join(\"\");\n                        hex = \"#\".concat(hexTemp);\n                    }\n                    return hex && \"0x\".concat(hex.substr(1));\n                }).filter(Boolean).map(normalizeColor);\n            }\n            constructor(...t){\n                e(this, \"el\", void 0), e(this, \"cssVarRetries\", 0), e(this, \"maxCssVarRetries\", 200), e(this, \"angle\", 0), e(this, \"isLoadedClass\", !1), e(this, \"isScrolling\", !1), /*e(this, \"isStatic\", o.disableAmbientAnimations()),*/ e(this, \"scrollingTimeout\", void 0), e(this, \"scrollingRefreshDelay\", 200), e(this, \"isIntersecting\", !1), e(this, \"shaderFiles\", void 0), e(this, \"vertexShader\", void 0), e(this, \"sectionColors\", void 0), e(this, \"computedCanvasStyle\", void 0), e(this, \"conf\", void 0), e(this, \"uniforms\", void 0), e(this, \"t\", 1253106), e(this, \"last\", 0), e(this, \"width\", void 0), e(this, \"minWidth\", 1111), e(this, \"height\", 600), e(this, \"xSegCount\", void 0), e(this, \"ySegCount\", void 0), e(this, \"mesh\", void 0), e(this, \"material\", void 0), e(this, \"geometry\", void 0), e(this, \"minigl\", void 0), e(this, \"scrollObserver\", void 0), e(this, \"amp\", 320), e(this, \"seed\", 5), e(this, \"freqX\", 14e-5), e(this, \"freqY\", 29e-5), e(this, \"freqDelta\", 1e-5), e(this, \"activeColors\", [\n                    1,\n                    1,\n                    1,\n                    1\n                ]), e(this, \"isMetaKey\", !1), e(this, \"isGradientLegendVisible\", !1), e(this, \"isMouseDown\", !1), e(this, \"handleScroll\", ()=>{\n                    clearTimeout(this.scrollingTimeout), this.scrollingTimeout = setTimeout(this.handleScrollEnd, this.scrollingRefreshDelay), this.isGradientLegendVisible && this.hideGradientLegend(), this.conf.playing && (this.isScrolling = !0, this.pause());\n                }), e(this, \"handleScrollEnd\", ()=>{\n                    this.isScrolling = !1, this.isIntersecting && this.play();\n                }), e(this, \"resize\", ()=>{\n                    this.width = window.innerWidth, this.minigl.setSize(this.width, this.height), this.minigl.setOrthographicCamera(), this.xSegCount = Math.ceil(this.width * this.conf.density[0]), this.ySegCount = Math.ceil(this.height * this.conf.density[1]), this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount), this.mesh.geometry.setSize(this.width, this.height), this.mesh.material.uniforms.u_shadow_power.value = this.width < 600 ? 5 : 6;\n                }), e(this, \"handleMouseDown\", (e)=>{\n                    this.isGradientLegendVisible && (this.isMetaKey = e.metaKey, this.isMouseDown = !0, !1 === this.conf.playing && requestAnimationFrame(this.animate));\n                }), e(this, \"handleMouseUp\", ()=>{\n                    this.isMouseDown = !1;\n                }), e(this, \"animate\", (e)=>{\n                    if (!this.shouldSkipFrame(e) || this.isMouseDown) {\n                        if (this.t += Math.min(e - this.last, 1e3 / 15), this.last = e, this.isMouseDown) {\n                            let e = 160;\n                            this.isMetaKey && (e = -160), this.t += e;\n                        }\n                        this.mesh.material.uniforms.u_time.value = this.t, this.minigl.render();\n                    }\n                    if (0 !== this.last && this.isStatic) return this.minigl.render(), void this.disconnect();\n                    /*this.isIntersecting && */ (this.conf.playing || this.isMouseDown) && requestAnimationFrame(this.animate);\n                }), e(this, \"addIsLoadedClass\", ()=>{\n                    /*this.isIntersecting && */ !this.isLoadedClass && (this.isLoadedClass = !0, this.el.classList.add(\"isLoaded\"), setTimeout(()=>{\n                        this.el.parentElement.classList.add(\"isLoaded\");\n                    }, 3e3));\n                }), e(this, \"pause\", ()=>{\n                    this.conf.playing = false;\n                }), e(this, \"play\", ()=>{\n                    requestAnimationFrame(this.animate), this.conf.playing = true;\n                }), e(this, \"initGradient\", (selector)=>{\n                    this.el = document.querySelector(selector);\n                    this.connect();\n                    return this;\n                });\n            }\n        }\n        /*\n     *Finally initializing the Gradient class, assigning a canvas to it and calling Gradient.connect() which initializes everything,\n     * Use Gradient.pause() and Gradient.play() for controls.\n     *\n     * Here are some default property values you can change anytime:\n     * Amplitude:    Gradient.amp = 0\n     * Colors:       Gradient.sectionColors (if you change colors, use normalizeColor(#hexValue)) before you assign it.\n     *\n     *\n     * Useful functions\n     * Gradient.toggleColor(index)\n     * Gradient.updateFrequency(freq)\n     */ var gradient = new Gradient();\n        gradient.initGradient(\"#gradient-canvas\");\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            id: \"gradient-canvas\",\n            //   style=\"width:100vw;height:100vh\"\n            className: \"w-full h-screen\"\n        }, void 0, false, {\n            fileName: \"/Users/admin/repos/SURVISION-landing-page/app/Stripe.js\",\n            lineNumber: 906,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/admin/repos/SURVISION-landing-page/app/Stripe.js\",\n        lineNumber: 905,\n        columnNumber: 5\n    }, this);\n}\n_s(Stripe, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = Stripe;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Stripe);\nvar _c;\n$RefreshReg$(_c, \"Stripe\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDMUYsRUFBRSxDQUFDdUQsU0FBUyxDQUFDQyxHQUFHLENBQUMsYUFDdEJtQixXQUFXO3dCQUNULElBQUksQ0FBQzNFLEVBQUUsQ0FBQzJGLGFBQWEsQ0FBQ3BDLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO29CQUN0QyxHQUFHLElBQUc7Z0JBQ1YsSUFDQXpPLEVBQUUsSUFBSSxFQUFFLFNBQVM7b0JBQ2YsSUFBSSxDQUFDeUssSUFBSSxDQUFDSyxPQUFPLEdBQUc7Z0JBQ3RCLElBQ0E5SyxFQUFFLElBQUksRUFBRSxRQUFRO29CQUNka0wsc0JBQXNCLElBQUksQ0FBQzJELE9BQU8sR0FBSSxJQUFJLENBQUNwRSxJQUFJLENBQUNLLE9BQU8sR0FBRztnQkFDNUQsSUFDQTlLLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixDQUFDNlE7b0JBQ3ZCLElBQUksQ0FBQzVGLEVBQUUsR0FBR3pKLFNBQVNzUCxhQUFhLENBQUNEO29CQUNqQyxJQUFJLENBQUMxRyxPQUFPO29CQUNaLE9BQU8sSUFBSTtnQkFDYjtZQUNKO1FBNFBGO1FBRUE7Ozs7Ozs7Ozs7OztLQVlDLEdBQ0QsSUFBSTRHLFdBQVcsSUFBSTdHO1FBQ25CNkcsU0FBU0MsWUFBWSxDQUFDO0lBQ3hCLEdBQUcsRUFBRTtJQUVMLHFCQUNFLDhEQUFDQztrQkFDQyw0RUFBQzlRO1lBQ0MrUSxJQUFHO1lBQ0gscUNBQXFDO1lBQ3JDQyxXQUFVOzs7Ozs7Ozs7OztBQUlsQjtHQTc0QlM3UjtLQUFBQTtBQSs0QlQsK0RBQWVBLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL1N0cmlwZS5qcz8xYTUwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5cbmZ1bmN0aW9uIFN0cmlwZSgpIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvKlxuICAgICAqICAgU3RyaXBlIFdlYkdsIEdyYWRpZW50IEFuaW1hdGlvbiBieSBTdHJpcGUuY29tXG4gICAgICogICBTY3JvbGxPYnNlcnZlciBmdW5jdGlvbmFsaXR5IHRvIGRpc2FibGUgYW5pbWF0aW9uIHdoZW4gbm90IHNjcm9sbGVkIGludG8gdmlldyBoYXMgYmVlbiBkaXNhYmxlZCBhbmRcbiAgICAgKiAgIGNvbW1lbnRlZCBvdXQgZm9yIG5vdy5cbiAgICAgKi9cblxuICAgIC8vQ29udmVydGluZyBjb2xvcnMgdG8gcHJvcGVyIGZvcm1hdFxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGhleENvZGUpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICgoaGV4Q29kZSA+PiAxNikgJiAyNTUpIC8gMjU1LFxuICAgICAgICAoKGhleENvZGUgPj4gOCkgJiAyNTUpIC8gMjU1LFxuICAgICAgICAoMjU1ICYgaGV4Q29kZSkgLyAyNTUsXG4gICAgICBdO1xuICAgIH1cbiAgICBbXCJTQ1JFRU5cIiwgXCJMSU5FQVJfTElHSFRcIl0ucmVkdWNlKFxuICAgICAgKGhleENvZGUsIHQsIG4pID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oaGV4Q29kZSwge1xuICAgICAgICAgIFt0XTogbixcbiAgICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG5cbiAgICAvL0Vzc2VudGlhbCBmdW5jdGlvbmFsaXR5IG9mIFdlYkdsXG4gICAgLy90ID0gd2lkdGhcbiAgICAvL24gPSBoZWlnaHRcbiAgICBjbGFzcyBNaW5pR2wge1xuICAgICAgY29uc3RydWN0b3IoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBkZWJ1ZyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IF9taW5pR2wgPSB0aGlzLFxuICAgICAgICAgIGRlYnVnX291dHB1dCA9XG4gICAgICAgICAgICAtMSAhPT1cbiAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLnNlYXJjaC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJkZWJ1Zz13ZWJnbFwiKTtcbiAgICAgICAgKF9taW5pR2wuY2FudmFzID0gY2FudmFzKSxcbiAgICAgICAgICAoX21pbmlHbC5nbCA9IF9taW5pR2wuY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCB7XG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIChfbWluaUdsLm1lc2hlcyA9IFtdKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IF9taW5pR2wuZ2w7XG4gICAgICAgIHdpZHRoICYmIGhlaWdodCAmJiB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCksXG4gICAgICAgICAgX21pbmlHbC5sYXN0RGVidWdNc2csXG4gICAgICAgICAgKF9taW5pR2wuZGVidWcgPVxuICAgICAgICAgICAgZGVidWcgJiYgZGVidWdfb3V0cHV0XG4gICAgICAgICAgICAgID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgdCAtIF9taW5pR2wubGFzdERlYnVnTXNnID4gMWUzICYmIGNvbnNvbGUubG9nKFwiLS0tXCIpLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICB0LnRvTG9jYWxlVGltZVN0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5KE1hdGgubWF4KDAsIDMyIC0gZS5sZW5ndGgpKS5qb2luKFwiIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiOiBcIixcbiAgICAgICAgICAgICAgICAgICAgICAuLi5BcnJheS5mcm9tKGFyZ3VtZW50cykuc2xpY2UoMSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgKF9taW5pR2wubGFzdERlYnVnTXNnID0gdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6ICgpID0+IHt9KSxcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfbWluaUdsLCB7XG4gICAgICAgICAgICBNYXRlcmlhbDoge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsdWU6IGNsYXNzIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTaGFkZXJzLCBmcmFnbWVudHMsIHVuaWZvcm1zID0ge30pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNoYWRlckJ5VHlwZSh0eXBlLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gY29udGV4dC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcGlsZVNoYWRlcihzaGFkZXIpLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZ2V0U2hhZGVyUGFyYW1ldGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5DT01QSUxFX1NUQVRVU1xuICAgICAgICAgICAgICAgICAgICAgICkgfHwgY29uc29sZS5lcnJvcihjb250ZXh0LmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSksXG4gICAgICAgICAgICAgICAgICAgICAgX21pbmlHbC5kZWJ1ZyhcIk1hdGVyaWFsLmNvbXBpbGVTaGFkZXJTb3VyY2VcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgc2hhZGVyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRVbmlmb3JtVmFyaWFibGVEZWNsYXJhdGlvbnModW5pZm9ybXMsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHVuaWZvcm1zKVxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKFt1bmlmb3JtLCB2YWx1ZV0pID0+XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5nZXREZWNsYXJhdGlvbih1bmlmb3JtLCB0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIChtYXRlcmlhbC51bmlmb3JtcyA9IHVuaWZvcm1zKSxcbiAgICAgICAgICAgICAgICAgICAgKG1hdGVyaWFsLnVuaWZvcm1JbnN0YW5jZXMgPSBbXSk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9XG4gICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgICAgICAgICAgXCI7XG4gICAgICAgICAgICAgICAgICAobWF0ZXJpYWwudmVydGV4U291cmNlID0gYFxcbiAgICAgICAgICAgICAgJHtwcmVmaXh9XFxuICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIHV2O1xcbiAgICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgdXZOb3JtO1xcbiAgICAgICAgICAgICAgJHtnZXRVbmlmb3JtVmFyaWFibGVEZWNsYXJhdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgIF9taW5pR2wuY29tbW9uVW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgIFwidmVydGV4XCJcbiAgICAgICAgICAgICAgICAgICl9XFxuICAgICAgICAgICAgICAke2dldFVuaWZvcm1WYXJpYWJsZURlY2xhcmF0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgIFwidmVydGV4XCJcbiAgICAgICAgICAgICAgICAgICl9XFxuICAgICAgICAgICAgICAke3ZlcnRleFNoYWRlcnN9XFxuICAgICAgICAgICAgYCksXG4gICAgICAgICAgICAgICAgICAgIChtYXRlcmlhbC5Tb3VyY2UgPSBgXFxuICAgICAgICAgICAgICAke3ByZWZpeH1cXG4gICAgICAgICAgICAgICR7Z2V0VW5pZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgIF9taW5pR2wuY29tbW9uVW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJmcmFnbWVudFwiXG4gICAgICAgICAgICAgICAgICAgICl9XFxuICAgICAgICAgICAgICAke2dldFVuaWZvcm1WYXJpYWJsZURlY2xhcmF0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgICBcImZyYWdtZW50XCJcbiAgICAgICAgICAgICAgICAgICAgKX1cXG4gICAgICAgICAgICAgICR7ZnJhZ21lbnRzfVxcbiAgICAgICAgICAgIGApLFxuICAgICAgICAgICAgICAgICAgICAobWF0ZXJpYWwudmVydGV4U2hhZGVyID0gZ2V0U2hhZGVyQnlUeXBlKFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuVkVSVEVYX1NIQURFUixcbiAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC52ZXJ0ZXhTb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGdldFNoYWRlckJ5VHlwZShcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LkZSQUdNRU5UX1NIQURFUixcbiAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5Tb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChtYXRlcmlhbC5wcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKCkpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmF0dGFjaFNoYWRlcihcbiAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5wcm9ncmFtLFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLnZlcnRleFNoYWRlclxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmF0dGFjaFNoYWRlcihcbiAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5wcm9ncmFtLFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGlua1Byb2dyYW0obWF0ZXJpYWwucHJvZ3JhbSksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZ2V0UHJvZ3JhbVBhcmFtZXRlcihcbiAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5wcm9ncmFtLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuTElOS19TVEFUVVNcbiAgICAgICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmdldFByb2dyYW1JbmZvTG9nKG1hdGVyaWFsLnByb2dyYW0pXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC51c2VQcm9ncmFtKG1hdGVyaWFsLnByb2dyYW0pLFxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5hdHRhY2hVbmlmb3Jtcyh2b2lkIDAsIF9taW5pR2wuY29tbW9uVW5pZm9ybXMpLFxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5hdHRhY2hVbmlmb3Jtcyh2b2lkIDAsIG1hdGVyaWFsLnVuaWZvcm1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy90ID0gdW5pZm9ybVxuICAgICAgICAgICAgICAgIGF0dGFjaFVuaWZvcm1zKG5hbWUsIHVuaWZvcm1zKSB7XG4gICAgICAgICAgICAgICAgICAvL24gID0gbWF0ZXJpYWxcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gbmFtZVxuICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKHVuaWZvcm1zKS5mb3JFYWNoKChbbmFtZSwgdW5pZm9ybV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLmF0dGFjaFVuaWZvcm1zKG5hbWUsIHVuaWZvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDogXCJhcnJheVwiID09IHVuaWZvcm1zLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyB1bmlmb3Jtcy52YWx1ZS5mb3JFYWNoKCh1bmlmb3JtLCBpKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwuYXR0YWNoVW5pZm9ybXMoYCR7bmFtZX1bJHtpfV1gLCB1bmlmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBcInN0cnVjdFwiID09IHVuaWZvcm1zLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuZW50cmllcyh1bmlmb3Jtcy52YWx1ZSkuZm9yRWFjaCgoW3VuaWZvcm0sIGldKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwuYXR0YWNoVW5pZm9ybXMoYCR7bmFtZX0uJHt1bmlmb3JtfWAsIGkpXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IChfbWluaUdsLmRlYnVnKFwiTWF0ZXJpYWwuYXR0YWNoVW5pZm9ybXNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm06IHVuaWZvcm1zLFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLnVuaWZvcm1JbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtOiB1bmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBjb250ZXh0LmdldFVuaWZvcm1Mb2NhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwucHJvZ3JhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFVuaWZvcm06IHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgIHZhbHVlOiBjbGFzcyB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoZSkge1xuICAgICAgICAgICAgICAgICAgKHRoaXMudHlwZSA9IFwiZmxvYXRcIiksIE9iamVjdC5hc3NpZ24odGhpcywgZSk7XG4gICAgICAgICAgICAgICAgICAodGhpcy50eXBlRm4gPVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgZmxvYXQ6IFwiMWZcIixcbiAgICAgICAgICAgICAgICAgICAgICBpbnQ6IFwiMWlcIixcbiAgICAgICAgICAgICAgICAgICAgICB2ZWMyOiBcIjJmdlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHZlYzM6IFwiM2Z2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgdmVjNDogXCI0ZnZcIixcbiAgICAgICAgICAgICAgICAgICAgICBtYXQ0OiBcIk1hdHJpeDRmdlwiLFxuICAgICAgICAgICAgICAgICAgICB9W3RoaXMudHlwZV0gfHwgXCIxZlwiKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHRoaXMudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFtgdW5pZm9ybSR7dGhpcy50eXBlRm59YF0oXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgMCA9PT0gdGhpcy50eXBlRm4uaW5kZXhPZihcIk1hdHJpeFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnRyYW5zcG9zZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIDAgPT09IHRoaXMudHlwZUZuLmluZGV4T2YoXCJNYXRyaXhcIikgPyB0aGlzLnZhbHVlIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2UgLSBuYW1lXG4gICAgICAgICAgICAgICAgLy90IC0gdHlwZVxuICAgICAgICAgICAgICAgIC8vbiAtIGxlbmd0aFxuICAgICAgICAgICAgICAgIGdldERlY2xhcmF0aW9uKG5hbWUsIHR5cGUsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdW5pZm9ybSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICBpZiAodW5pZm9ybS5leGNsdWRlRnJvbSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJhcnJheVwiID09PSB1bmlmb3JtLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0udmFsdWVbMF0/LmdldERlY2xhcmF0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtLnZhbHVlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxuY29uc3QgaW50ICR7bmFtZX1fbGVuZ3RoID0gJHt1bmlmb3JtLnZhbHVlLmxlbmd0aH07YFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInN0cnVjdFwiID09PSB1bmlmb3JtLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZV9ub19wcmVmaXggPSBuYW1lLnJlcGxhY2UoXCJ1X1wiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWVfbm9fcHJlZml4ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZV9ub19wcmVmaXguY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lX25vX3ByZWZpeC5zbGljZSgxKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBgdW5pZm9ybSBzdHJ1Y3QgJHtuYW1lX25vX3ByZWZpeH0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh1bmlmb3JtLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKFtuYW1lLCB1bmlmb3JtXSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldERlY2xhcmF0aW9uKG5hbWUsIHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9edW5pZm9ybS8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbn0gJHtuYW1lfSR7bGVuZ3RoID4gMCA/IGBbJHtsZW5ndGh9XWAgOiBcIlwifTtgXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHVuaWZvcm0gJHt1bmlmb3JtLnR5cGV9ICR7bmFtZX0ke1xuICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+IDAgPyBgWyR7bGVuZ3RofV1gIDogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9O2A7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFBsYW5lR2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgIHZhbHVlOiBjbGFzcyB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgbiwgaSwgb3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuY3JlYXRlQnVmZmVyKCksXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5ldyBfbWluaUdsLkF0dHJpYnV0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRleHQuQVJSQVlfQlVGRkVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICB1djogbmV3IF9taW5pR2wuQXR0cmlidXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogY29udGV4dC5BUlJBWV9CVUZGRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIHV2Tm9ybTogbmV3IF9taW5pR2wuQXR0cmlidXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogY29udGV4dC5BUlJBWV9CVUZGRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBuZXcgX21pbmlHbC5BdHRyaWJ1dGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbnRleHQuVU5TSUdORURfU0hPUlQsXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRvcG9sb2d5KG4sIGkpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCwgb3JpZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRUb3BvbG9neShlID0gMSwgdCA9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgKG4ueFNlZ0NvdW50ID0gZSksXG4gICAgICAgICAgICAgICAgICAgIChuLnlTZWdDb3VudCA9IHQpLFxuICAgICAgICAgICAgICAgICAgICAobi52ZXJ0ZXhDb3VudCA9IChuLnhTZWdDb3VudCArIDEpICogKG4ueVNlZ0NvdW50ICsgMSkpLFxuICAgICAgICAgICAgICAgICAgICAobi5xdWFkQ291bnQgPSBuLnhTZWdDb3VudCAqIG4ueVNlZ0NvdW50ICogMiksXG4gICAgICAgICAgICAgICAgICAgIChuLmF0dHJpYnV0ZXMudXYudmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAyICogbi52ZXJ0ZXhDb3VudFxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKG4uYXR0cmlidXRlcy51dk5vcm0udmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAyICogbi52ZXJ0ZXhDb3VudFxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKG4uYXR0cmlidXRlcy5pbmRleC52YWx1ZXMgPSBuZXcgVWludDE2QXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgMyAqIG4ucXVhZENvdW50XG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPD0gbi55U2VnQ291bnQ7IGUrKylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPD0gbi54U2VnQ291bnQ7IHQrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBlICogKG4ueFNlZ0NvdW50ICsgMSkgKyB0O1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICgobi5hdHRyaWJ1dGVzLnV2LnZhbHVlc1syICogaV0gPSB0IC8gbi54U2VnQ291bnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKG4uYXR0cmlidXRlcy51di52YWx1ZXNbMiAqIGkgKyAxXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDEgLSBlIC8gbi55U2VnQ291bnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKG4uYXR0cmlidXRlcy51dk5vcm0udmFsdWVzWzIgKiBpXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICh0IC8gbi54U2VnQ291bnQpICogMiAtIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKG4uYXR0cmlidXRlcy51dk5vcm0udmFsdWVzWzIgKiBpICsgMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAxIC0gKGUgLyBuLnlTZWdDb3VudCkgKiAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPCBuLnhTZWdDb3VudCAmJiBlIDwgbi55U2VnQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gZSAqIG4ueFNlZ0NvdW50ICsgdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIChuLmF0dHJpYnV0ZXMuaW5kZXgudmFsdWVzWzYgKiBzXSA9IGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAobi5hdHRyaWJ1dGVzLmluZGV4LnZhbHVlc1s2ICogcyArIDFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICsgMSArIG4ueFNlZ0NvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKG4uYXR0cmlidXRlcy5pbmRleC52YWx1ZXNbNiAqIHMgKyAyXSA9IGkgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKG4uYXR0cmlidXRlcy5pbmRleC52YWx1ZXNbNiAqIHMgKyAzXSA9IGkgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKG4uYXR0cmlidXRlcy5pbmRleC52YWx1ZXNbNiAqIHMgKyA0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArIDEgKyBuLnhTZWdDb3VudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChuLmF0dHJpYnV0ZXMuaW5kZXgudmFsdWVzWzYgKiBzICsgNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKyAyICsgbi54U2VnQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbi5hdHRyaWJ1dGVzLnV2LnVwZGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBuLmF0dHJpYnV0ZXMudXZOb3JtLnVwZGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBuLmF0dHJpYnV0ZXMuaW5kZXgudXBkYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIF9taW5pR2wuZGVidWcoXCJHZW9tZXRyeS5zZXRUb3BvbG9neVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdXY6IG4uYXR0cmlidXRlcy51dixcbiAgICAgICAgICAgICAgICAgICAgICB1dk5vcm06IG4uYXR0cmlidXRlcy51dk5vcm0sXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG4uYXR0cmlidXRlcy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFNpemUod2lkdGggPSAxLCBoZWlnaHQgPSAxLCBvcmllbnRhdGlvbiA9IFwieHpcIikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgKGdlb21ldHJ5LndpZHRoID0gd2lkdGgpLFxuICAgICAgICAgICAgICAgICAgICAoZ2VvbWV0cnkuaGVpZ2h0ID0gaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgKGdlb21ldHJ5Lm9yaWVudGF0aW9uID0gb3JpZW50YXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAoZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi52YWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnZhbHVlcy5sZW5ndGggPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAzICogZ2VvbWV0cnkudmVydGV4Q291bnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgIDMgKiBnZW9tZXRyeS52ZXJ0ZXhDb3VudFxuICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgbyA9IHdpZHRoIC8gLTIsXG4gICAgICAgICAgICAgICAgICAgIHIgPSBoZWlnaHQgLyAtMixcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ2VvbWV0cnkueFNlZ0NvdW50LFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdlb21ldHJ5LnlTZWdDb3VudDtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IHlJbmRleCA9IDA7IHlJbmRleCA8PSBnZW9tZXRyeS55U2VnQ291bnQ7IHlJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSByICsgeUluZGV4ICogc2VnbWVudF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgICAgbGV0IHhJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgeEluZGV4IDw9IGdlb21ldHJ5LnhTZWdDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICB4SW5kZXgrK1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gbyArIHhJbmRleCAqIHNlZ21lbnRfd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0geUluZGV4ICogKGdlb21ldHJ5LnhTZWdDb3VudCArIDEpICsgeEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgIChnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnZhbHVlc1tcbiAgICAgICAgICAgICAgICAgICAgICAgIDMgKiBsICsgXCJ4eXpcIi5pbmRleE9mKG9yaWVudGF0aW9uWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIF0gPSByKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnZhbHVlc1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMyAqIGwgKyBcInh5elwiLmluZGV4T2Yob3JpZW50YXRpb25bMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdID0gLXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnVwZGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBfbWluaUdsLmRlYnVnKFwiR2VvbWV0cnkuc2V0U2l6ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBNZXNoOiB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICB2YWx1ZTogY2xhc3Mge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWVzaCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAobWVzaC5nZW9tZXRyeSA9IGdlb21ldHJ5KSxcbiAgICAgICAgICAgICAgICAgICAgKG1lc2gubWF0ZXJpYWwgPSBtYXRlcmlhbCksXG4gICAgICAgICAgICAgICAgICAgIChtZXNoLndpcmVmcmFtZSA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgKG1lc2guYXR0cmlidXRlSW5zdGFuY2VzID0gW10pLFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhtZXNoLmdlb21ldHJ5LmF0dHJpYnV0ZXMpLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgKFtlLCBhdHRyaWJ1dGVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmF0dHJpYnV0ZUluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBhdHRyaWJ1dGUuYXR0YWNoKGUsIG1lc2gubWF0ZXJpYWwucHJvZ3JhbSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIF9taW5pR2wubWVzaGVzLnB1c2gobWVzaCksXG4gICAgICAgICAgICAgICAgICAgIF9taW5pR2wuZGVidWcoXCJNZXNoLmNvbnN0cnVjdG9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBtZXNoOiBtZXNoLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHJhdygpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQudXNlUHJvZ3JhbSh0aGlzLm1hdGVyaWFsLnByb2dyYW0pLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1JbnN0YW5jZXMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgICAgICAoeyB1bmlmb3JtOiBlLCBsb2NhdGlvbjogdCB9KSA9PiBlLnVwZGF0ZSh0KVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZUluc3RhbmNlcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICAgICh7IGF0dHJpYnV0ZTogZSwgbG9jYXRpb246IHQgfSkgPT4gZS51c2UodClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3RWxlbWVudHMoXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy53aXJlZnJhbWUgPyBjb250ZXh0LkxJTkVTIDogY29udGV4dC5UUklBTkdMRVMsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLmluZGV4LnZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5VTlNJR05FRF9TSE9SVCxcbiAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW92ZSgpIHtcbiAgICAgICAgICAgICAgICAgIF9taW5pR2wubWVzaGVzID0gX21pbmlHbC5tZXNoZXMuZmlsdGVyKChlKSA9PiBlICE9IHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBBdHRyaWJ1dGU6IHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgIHZhbHVlOiBjbGFzcyB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoZSkge1xuICAgICAgICAgICAgICAgICAgKHRoaXMudHlwZSA9IGNvbnRleHQuRkxPQVQpLFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5ub3JtYWxpemVkID0gITEpLFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5idWZmZXIgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlcigpKSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBlKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlKCkge1xuICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSB0aGlzLnZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICAoY29udGV4dC5iaW5kQnVmZmVyKHRoaXMudGFyZ2V0LCB0aGlzLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYnVmZmVyRGF0YShcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LlNUQVRJQ19EUkFXXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdHRhY2goZSwgdCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IGNvbnRleHQuZ2V0QXR0cmliTG9jYXRpb24odCwgZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9PT0gY29udGV4dC5BUlJBWV9CVUZGRVIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoY29udGV4dC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShuKSxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgblxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXNlKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuYmluZEJ1ZmZlcih0aGlzLnRhcmdldCwgdGhpcy5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9PT0gY29udGV4dC5BUlJBWV9CVUZGRVIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoY29udGV4dC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShlKSxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuICAgICAgICBfbWluaUdsLmNvbW1vblVuaWZvcm1zID0ge1xuICAgICAgICAgIHByb2plY3Rpb25NYXRyaXg6IG5ldyBfbWluaUdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgdHlwZTogXCJtYXQ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogYSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtb2RlbFZpZXdNYXRyaXg6IG5ldyBfbWluaUdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgdHlwZTogXCJtYXQ0XCIsXG4gICAgICAgICAgICB2YWx1ZTogYSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICByZXNvbHV0aW9uOiBuZXcgX21pbmlHbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgIHR5cGU6IFwidmVjMlwiLFxuICAgICAgICAgICAgdmFsdWU6IFsxLCAxXSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBhc3BlY3RSYXRpbzogbmV3IF9taW5pR2wuVW5pZm9ybSh7XG4gICAgICAgICAgICB0eXBlOiBcImZsb2F0XCIsXG4gICAgICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNldFNpemUoZSA9IDY0MCwgdCA9IDQ4MCkge1xuICAgICAgICAodGhpcy53aWR0aCA9IGUpLFxuICAgICAgICAgICh0aGlzLmhlaWdodCA9IHQpLFxuICAgICAgICAgICh0aGlzLmNhbnZhcy53aWR0aCA9IGUpLFxuICAgICAgICAgICh0aGlzLmNhbnZhcy5oZWlnaHQgPSB0KSxcbiAgICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIGUsIHQpLFxuICAgICAgICAgICh0aGlzLmNvbW1vblVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUgPSBbZSwgdF0pLFxuICAgICAgICAgICh0aGlzLmNvbW1vblVuaWZvcm1zLmFzcGVjdFJhdGlvLnZhbHVlID0gZSAvIHQpLFxuICAgICAgICAgIHRoaXMuZGVidWcoXCJNaW5pR0wuc2V0U2l6ZVwiLCB7XG4gICAgICAgICAgICB3aWR0aDogZSxcbiAgICAgICAgICAgIGhlaWdodDogdCxcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXJcbiAgICAgIHNldE9ydGhvZ3JhcGhpY0NhbWVyYShlID0gMCwgdCA9IDAsIG4gPSAwLCBpID0gLTJlMywgcyA9IDJlMykge1xuICAgICAgICAodGhpcy5jb21tb25Vbmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LnZhbHVlID0gW1xuICAgICAgICAgIDIgLyB0aGlzLndpZHRoLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMiAvIHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMiAvIChpIC0gcyksXG4gICAgICAgICAgMCxcbiAgICAgICAgICBlLFxuICAgICAgICAgIHQsXG4gICAgICAgICAgbixcbiAgICAgICAgICAxLFxuICAgICAgICBdKSxcbiAgICAgICAgICB0aGlzLmRlYnVnKFxuICAgICAgICAgICAgXCJzZXRPcnRob2dyYXBoaWNDYW1lcmFcIixcbiAgICAgICAgICAgIHRoaXMuY29tbW9uVW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC52YWx1ZVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKSxcbiAgICAgICAgICB0aGlzLmdsLmNsZWFyRGVwdGgoMSksXG4gICAgICAgICAgdGhpcy5tZXNoZXMuZm9yRWFjaCgoZSkgPT4gZS5kcmF3KCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vU2V0cyBpbml0aWFsIHByb3BlcnRpZXNcbiAgICBmdW5jdGlvbiBlKG9iamVjdCwgcHJvcGVydHlOYW1lLCB2YWwpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHByb3BlcnR5TmFtZSBpbiBvYmplY3RcbiAgICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IChvYmplY3RbcHJvcGVydHlOYW1lXSA9IHZhbCksXG4gICAgICAgIG9iamVjdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvL0dyYWRpZW50IG9iamVjdFxuICAgIGNsYXNzIEdyYWRpZW50IHtcbiAgICAgIGNvbnN0cnVjdG9yKC4uLnQpIHtcbiAgICAgICAgZSh0aGlzLCBcImVsXCIsIHZvaWQgMCksXG4gICAgICAgICAgZSh0aGlzLCBcImNzc1ZhclJldHJpZXNcIiwgMCksXG4gICAgICAgICAgZSh0aGlzLCBcIm1heENzc1ZhclJldHJpZXNcIiwgMjAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwiYW5nbGVcIiwgMCksXG4gICAgICAgICAgZSh0aGlzLCBcImlzTG9hZGVkQ2xhc3NcIiwgITEpLFxuICAgICAgICAgIGUodGhpcywgXCJpc1Njcm9sbGluZ1wiLCAhMSksXG4gICAgICAgICAgLyplKHRoaXMsIFwiaXNTdGF0aWNcIiwgby5kaXNhYmxlQW1iaWVudEFuaW1hdGlvbnMoKSksKi8gZShcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBcInNjcm9sbGluZ1RpbWVvdXRcIixcbiAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICksXG4gICAgICAgICAgZSh0aGlzLCBcInNjcm9sbGluZ1JlZnJlc2hEZWxheVwiLCAyMDApLFxuICAgICAgICAgIGUodGhpcywgXCJpc0ludGVyc2VjdGluZ1wiLCAhMSksXG4gICAgICAgICAgZSh0aGlzLCBcInNoYWRlckZpbGVzXCIsIHZvaWQgMCksXG4gICAgICAgICAgZSh0aGlzLCBcInZlcnRleFNoYWRlclwiLCB2b2lkIDApLFxuICAgICAgICAgIGUodGhpcywgXCJzZWN0aW9uQ29sb3JzXCIsIHZvaWQgMCksXG4gICAgICAgICAgZSh0aGlzLCBcImNvbXB1dGVkQ2FudmFzU3R5bGVcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwiY29uZlwiLCB2b2lkIDApLFxuICAgICAgICAgIGUodGhpcywgXCJ1bmlmb3Jtc1wiLCB2b2lkIDApLFxuICAgICAgICAgIGUodGhpcywgXCJ0XCIsIDEyNTMxMDYpLFxuICAgICAgICAgIGUodGhpcywgXCJsYXN0XCIsIDApLFxuICAgICAgICAgIGUodGhpcywgXCJ3aWR0aFwiLCB2b2lkIDApLFxuICAgICAgICAgIGUodGhpcywgXCJtaW5XaWR0aFwiLCAxMTExKSxcbiAgICAgICAgICBlKHRoaXMsIFwiaGVpZ2h0XCIsIDYwMCksXG4gICAgICAgICAgZSh0aGlzLCBcInhTZWdDb3VudFwiLCB2b2lkIDApLFxuICAgICAgICAgIGUodGhpcywgXCJ5U2VnQ291bnRcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwibWVzaFwiLCB2b2lkIDApLFxuICAgICAgICAgIGUodGhpcywgXCJtYXRlcmlhbFwiLCB2b2lkIDApLFxuICAgICAgICAgIGUodGhpcywgXCJnZW9tZXRyeVwiLCB2b2lkIDApLFxuICAgICAgICAgIGUodGhpcywgXCJtaW5pZ2xcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwic2Nyb2xsT2JzZXJ2ZXJcIiwgdm9pZCAwKSxcbiAgICAgICAgICBlKHRoaXMsIFwiYW1wXCIsIDMyMCksXG4gICAgICAgICAgZSh0aGlzLCBcInNlZWRcIiwgNSksXG4gICAgICAgICAgZSh0aGlzLCBcImZyZXFYXCIsIDE0ZS01KSxcbiAgICAgICAgICBlKHRoaXMsIFwiZnJlcVlcIiwgMjllLTUpLFxuICAgICAgICAgIGUodGhpcywgXCJmcmVxRGVsdGFcIiwgMWUtNSksXG4gICAgICAgICAgZSh0aGlzLCBcImFjdGl2ZUNvbG9yc1wiLCBbMSwgMSwgMSwgMV0pLFxuICAgICAgICAgIGUodGhpcywgXCJpc01ldGFLZXlcIiwgITEpLFxuICAgICAgICAgIGUodGhpcywgXCJpc0dyYWRpZW50TGVnZW5kVmlzaWJsZVwiLCAhMSksXG4gICAgICAgICAgZSh0aGlzLCBcImlzTW91c2VEb3duXCIsICExKSxcbiAgICAgICAgICBlKHRoaXMsIFwiaGFuZGxlU2Nyb2xsXCIsICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNjcm9sbGluZ1RpbWVvdXQpLFxuICAgICAgICAgICAgICAodGhpcy5zY3JvbGxpbmdUaW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbEVuZCxcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZ1JlZnJlc2hEZWxheVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgdGhpcy5pc0dyYWRpZW50TGVnZW5kVmlzaWJsZSAmJiB0aGlzLmhpZGVHcmFkaWVudExlZ2VuZCgpLFxuICAgICAgICAgICAgICB0aGlzLmNvbmYucGxheWluZyAmJiAoKHRoaXMuaXNTY3JvbGxpbmcgPSAhMCksIHRoaXMucGF1c2UoKSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZSh0aGlzLCBcImhhbmRsZVNjcm9sbEVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAodGhpcy5pc1Njcm9sbGluZyA9ICExKSwgdGhpcy5pc0ludGVyc2VjdGluZyAmJiB0aGlzLnBsYXkoKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBlKHRoaXMsIFwicmVzaXplXCIsICgpID0+IHtcbiAgICAgICAgICAgICh0aGlzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGgpLFxuICAgICAgICAgICAgICB0aGlzLm1pbmlnbC5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgdGhpcy5taW5pZ2wuc2V0T3J0aG9ncmFwaGljQ2FtZXJhKCksXG4gICAgICAgICAgICAgICh0aGlzLnhTZWdDb3VudCA9IE1hdGguY2VpbCh0aGlzLndpZHRoICogdGhpcy5jb25mLmRlbnNpdHlbMF0pKSxcbiAgICAgICAgICAgICAgKHRoaXMueVNlZ0NvdW50ID0gTWF0aC5jZWlsKHRoaXMuaGVpZ2h0ICogdGhpcy5jb25mLmRlbnNpdHlbMV0pKSxcbiAgICAgICAgICAgICAgdGhpcy5tZXNoLmdlb21ldHJ5LnNldFRvcG9sb2d5KHRoaXMueFNlZ0NvdW50LCB0aGlzLnlTZWdDb3VudCksXG4gICAgICAgICAgICAgIHRoaXMubWVzaC5nZW9tZXRyeS5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgKHRoaXMubWVzaC5tYXRlcmlhbC51bmlmb3Jtcy51X3NoYWRvd19wb3dlci52YWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA8IDYwMCA/IDUgOiA2KTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBlKHRoaXMsIFwiaGFuZGxlTW91c2VEb3duXCIsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzR3JhZGllbnRMZWdlbmRWaXNpYmxlICYmXG4gICAgICAgICAgICAgICgodGhpcy5pc01ldGFLZXkgPSBlLm1ldGFLZXkpLFxuICAgICAgICAgICAgICAodGhpcy5pc01vdXNlRG93biA9ICEwKSxcbiAgICAgICAgICAgICAgITEgPT09IHRoaXMuY29uZi5wbGF5aW5nICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGUpKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBlKHRoaXMsIFwiaGFuZGxlTW91c2VVcFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzTW91c2VEb3duID0gITE7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZSh0aGlzLCBcImFuaW1hdGVcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRTa2lwRnJhbWUoZSkgfHwgdGhpcy5pc01vdXNlRG93bikge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKCh0aGlzLnQgKz0gTWF0aC5taW4oZSAtIHRoaXMubGFzdCwgMWUzIC8gMTUpKSxcbiAgICAgICAgICAgICAgICAodGhpcy5sYXN0ID0gZSksXG4gICAgICAgICAgICAgICAgdGhpcy5pc01vdXNlRG93bilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbGV0IGUgPSAxNjA7XG4gICAgICAgICAgICAgICAgdGhpcy5pc01ldGFLZXkgJiYgKGUgPSAtMTYwKSwgKHRoaXMudCArPSBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAodGhpcy5tZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnVfdGltZS52YWx1ZSA9IHRoaXMudCksXG4gICAgICAgICAgICAgICAgdGhpcy5taW5pZ2wucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMCAhPT0gdGhpcy5sYXN0ICYmIHRoaXMuaXNTdGF0aWMpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbmlnbC5yZW5kZXIoKSwgdm9pZCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIC8qdGhpcy5pc0ludGVyc2VjdGluZyAmJiAqLyAodGhpcy5jb25mLnBsYXlpbmcgfHxcbiAgICAgICAgICAgICAgdGhpcy5pc01vdXNlRG93bikgJiZcbiAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZSh0aGlzLCBcImFkZElzTG9hZGVkQ2xhc3NcIiwgKCkgPT4ge1xuICAgICAgICAgICAgLyp0aGlzLmlzSW50ZXJzZWN0aW5nICYmICovICF0aGlzLmlzTG9hZGVkQ2xhc3MgJiZcbiAgICAgICAgICAgICAgKCh0aGlzLmlzTG9hZGVkQ2xhc3MgPSAhMCksXG4gICAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImlzTG9hZGVkXCIpLFxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImlzTG9hZGVkXCIpO1xuICAgICAgICAgICAgICB9LCAzZTMpKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBlKHRoaXMsIFwicGF1c2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25mLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBlKHRoaXMsIFwicGxheVwiLCAoKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKSwgKHRoaXMuY29uZi5wbGF5aW5nID0gdHJ1ZSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZSh0aGlzLCBcImluaXRHcmFkaWVudFwiLCAoc2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhc3luYyBjb25uZWN0KCkge1xuICAgICAgICAodGhpcy5zaGFkZXJGaWxlcyA9IHtcbiAgICAgICAgICB2ZXJ0ZXg6XG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMyB2X2NvbG9yO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGZsb2F0IHRpbWUgPSB1X3RpbWUgKiB1X2dsb2JhbC5ub2lzZVNwZWVkO1xcblxcbiAgdmVjMiBub2lzZUNvb3JkID0gcmVzb2x1dGlvbiAqIHV2Tm9ybSAqIHVfZ2xvYmFsLm5vaXNlRnJlcTtcXG5cXG4gIHZlYzIgc3QgPSAxLiAtIHV2Tm9ybS54eTtcXG5cXG4gIC8vXFxuICAvLyBUaWx0aW5nIHRoZSBwbGFuZVxcbiAgLy9cXG5cXG4gIC8vIEZyb250LXRvLWJhY2sgdGlsdFxcbiAgZmxvYXQgdGlsdCA9IHJlc29sdXRpb24ueSAvIDIuMCAqIHV2Tm9ybS55O1xcblxcbiAgLy8gTGVmdC10by1yaWdodCBhbmdsZVxcbiAgZmxvYXQgaW5jbGluZSA9IHJlc29sdXRpb24ueCAqIHV2Tm9ybS54IC8gMi4wICogdV92ZXJ0RGVmb3JtLmluY2xpbmU7XFxuXFxuICAvLyBVcC1kb3duIHNoaWZ0IHRvIG9mZnNldCBpbmNsaW5lXFxuICBmbG9hdCBvZmZzZXQgPSByZXNvbHV0aW9uLnggLyAyLjAgKiB1X3ZlcnREZWZvcm0uaW5jbGluZSAqIG1peCh1X3ZlcnREZWZvcm0ub2Zmc2V0Qm90dG9tLCB1X3ZlcnREZWZvcm0ub2Zmc2V0VG9wLCB1di55KTtcXG5cXG4gIC8vXFxuICAvLyBWZXJ0ZXggbm9pc2VcXG4gIC8vXFxuXFxuICBmbG9hdCBub2lzZSA9IHNub2lzZSh2ZWMzKFxcbiAgICBub2lzZUNvb3JkLnggKiB1X3ZlcnREZWZvcm0ubm9pc2VGcmVxLnggKyB0aW1lICogdV92ZXJ0RGVmb3JtLm5vaXNlRmxvdyxcXG4gICAgbm9pc2VDb29yZC55ICogdV92ZXJ0RGVmb3JtLm5vaXNlRnJlcS55LFxcbiAgICB0aW1lICogdV92ZXJ0RGVmb3JtLm5vaXNlU3BlZWQgKyB1X3ZlcnREZWZvcm0ubm9pc2VTZWVkXFxuICApKSAqIHVfdmVydERlZm9ybS5ub2lzZUFtcDtcXG5cXG4gIC8vIEZhZGUgbm9pc2UgdG8gemVybyBhdCBlZGdlc1xcbiAgbm9pc2UgKj0gMS4wIC0gcG93KGFicyh1dk5vcm0ueSksIDIuMCk7XFxuXFxuICAvLyBDbGFtcCB0byAwXFxuICBub2lzZSA9IG1heCgwLjAsIG5vaXNlKTtcXG5cXG4gIHZlYzMgcG9zID0gdmVjMyhcXG4gICAgcG9zaXRpb24ueCxcXG4gICAgcG9zaXRpb24ueSArIHRpbHQgKyBpbmNsaW5lICsgbm9pc2UgLSBvZmZzZXQsXFxuICAgIHBvc2l0aW9uLnpcXG4gICk7XFxuXFxuICAvL1xcbiAgLy8gVmVydGV4IGNvbG9yLCB0byBiZSBwYXNzZWQgdG8gZnJhZ21lbnQgc2hhZGVyXFxuICAvL1xcblxcbiAgaWYgKHVfYWN0aXZlX2NvbG9yc1swXSA9PSAxLikge1xcbiAgICB2X2NvbG9yID0gdV9iYXNlQ29sb3I7XFxuICB9XFxuXFxuICBmb3IgKGludCBpID0gMDsgaSA8IHVfd2F2ZUxheWVyc19sZW5ndGg7IGkrKykge1xcbiAgICBpZiAodV9hY3RpdmVfY29sb3JzW2kgKyAxXSA9PSAxLikge1xcbiAgICAgIFdhdmVMYXllcnMgbGF5ZXIgPSB1X3dhdmVMYXllcnNbaV07XFxuXFxuICAgICAgZmxvYXQgbm9pc2UgPSBzbW9vdGhzdGVwKFxcbiAgICAgICAgbGF5ZXIubm9pc2VGbG9vcixcXG4gICAgICAgIGxheWVyLm5vaXNlQ2VpbCxcXG4gICAgICAgIHNub2lzZSh2ZWMzKFxcbiAgICAgICAgICBub2lzZUNvb3JkLnggKiBsYXllci5ub2lzZUZyZXEueCArIHRpbWUgKiBsYXllci5ub2lzZUZsb3csXFxuICAgICAgICAgIG5vaXNlQ29vcmQueSAqIGxheWVyLm5vaXNlRnJlcS55LFxcbiAgICAgICAgICB0aW1lICogbGF5ZXIubm9pc2VTcGVlZCArIGxheWVyLm5vaXNlU2VlZFxcbiAgICAgICAgKSkgLyAyLjAgKyAwLjVcXG4gICAgICApO1xcblxcbiAgICAgIHZfY29sb3IgPSBibGVuZE5vcm1hbCh2X2NvbG9yLCBsYXllci5jb2xvciwgcG93KG5vaXNlLCA0LikpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvL1xcbiAgLy8gRmluaXNoXFxuICAvL1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3MsIDEuMCk7XFxufVwiLFxuICAgICAgICAgIG5vaXNlOlxuICAgICAgICAgICAgXCIvL1xcbi8vIERlc2NyaXB0aW9uIDogQXJyYXkgYW5kIHRleHR1cmVsZXNzIEdMU0wgMkQvM0QvNEQgc2ltcGxleFxcbi8vICAgICAgICAgICAgICAgbm9pc2UgZnVuY3Rpb25zLlxcbi8vICAgICAgQXV0aG9yIDogSWFuIE1jRXdhbiwgQXNoaW1hIEFydHMuXFxuLy8gIE1haW50YWluZXIgOiBzdGVndVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGVndS93ZWJnbC1ub2lzZVxcbi8vXFxuXFxudmVjMyBtb2QyODkodmVjMyB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5cXG52ZWM0IG1vZDI4OSh2ZWM0IHgpIHtcXG4gIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7XFxufVxcblxcbnZlYzQgcGVybXV0ZSh2ZWM0IHgpIHtcXG4gICAgcmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTtcXG59XFxuXFxudmVjNCB0YXlsb3JJbnZTcXJ0KHZlYzQgcilcXG57XFxuICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcbn1cXG5cXG5mbG9hdCBzbm9pc2UodmVjMyB2KVxcbntcXG4gIGNvbnN0IHZlYzIgIEMgPSB2ZWMyKDEuMC82LjAsIDEuMC8zLjApIDtcXG4gIGNvbnN0IHZlYzQgIEQgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDIuMCk7XFxuXFxuLy8gRmlyc3QgY29ybmVyXFxuICB2ZWMzIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5eSkgKTtcXG4gIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KSA7XFxuXFxuLy8gT3RoZXIgY29ybmVyc1xcbiAgdmVjMyBnID0gc3RlcCh4MC55engsIHgwLnh5eik7XFxuICB2ZWMzIGwgPSAxLjAgLSBnO1xcbiAgdmVjMyBpMSA9IG1pbiggZy54eXosIGwuenh5ICk7XFxuICB2ZWMzIGkyID0gbWF4KCBnLnh5eiwgbC56eHkgKTtcXG5cXG4gIC8vICAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4O1xcbiAgLy8gICB4MSA9IHgwIC0gaTEgICsgMS4wICogQy54eHg7XFxuICAvLyAgIHgyID0geDAgLSBpMiAgKyAyLjAgKiBDLnh4eDtcXG4gIC8vICAgeDMgPSB4MCAtIDEuMCArIDMuMCAqIEMueHh4O1xcbiAgdmVjMyB4MSA9IHgwIC0gaTEgKyBDLnh4eDtcXG4gIHZlYzMgeDIgPSB4MCAtIGkyICsgQy55eXk7IC8vIDIuMCpDLnggPSAxLzMgPSBDLnlcXG4gIHZlYzMgeDMgPSB4MCAtIEQueXl5OyAgICAgIC8vIC0xLjArMy4wKkMueCA9IC0wLjUgPSAtRC55XFxuXFxuLy8gUGVybXV0YXRpb25zXFxuICBpID0gbW9kMjg5KGkpO1xcbiAgdmVjNCBwID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZShcXG4gICAgICAgICAgICBpLnogKyB2ZWM0KDAuMCwgaTEueiwgaTIueiwgMS4wICkpXFxuICAgICAgICAgICsgaS55ICsgdmVjNCgwLjAsIGkxLnksIGkyLnksIDEuMCApKVxcbiAgICAgICAgICArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XFxuXFxuLy8gR3JhZGllbnRzOiA3eDcgcG9pbnRzIG92ZXIgYSBzcXVhcmUsIG1hcHBlZCBvbnRvIGFuIG9jdGFoZWRyb24uXFxuLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQ5ICg0OSo2ID0gMjk0KVxcbiAgZmxvYXQgbl8gPSAwLjE0Mjg1NzE0Mjg1NzsgLy8gMS4wLzcuMFxcbiAgdmVjMyAgbnMgPSBuXyAqIEQud3l6IC0gRC54eng7XFxuXFxuICB2ZWM0IGogPSBwIC0gNDkuMCAqIGZsb29yKHAgKiBucy56ICogbnMueik7ICAvLyAgbW9kKHAsNyo3KVxcblxcbiAgdmVjNCB4XyA9IGZsb29yKGogKiBucy56KTtcXG4gIHZlYzQgeV8gPSBmbG9vcihqIC0gNy4wICogeF8gKTsgICAgLy8gbW9kKGosTilcXG5cXG4gIHZlYzQgeCA9IHhfICpucy54ICsgbnMueXl5eTtcXG4gIHZlYzQgeSA9IHlfICpucy54ICsgbnMueXl5eTtcXG4gIHZlYzQgaCA9IDEuMCAtIGFicyh4KSAtIGFicyh5KTtcXG5cXG4gIHZlYzQgYjAgPSB2ZWM0KCB4Lnh5LCB5Lnh5ICk7XFxuICB2ZWM0IGIxID0gdmVjNCggeC56dywgeS56dyApO1xcblxcbiAgLy92ZWM0IHMwID0gdmVjNChsZXNzVGhhbihiMCwwLjApKSoyLjAgLSAxLjA7XFxuICAvL3ZlYzQgczEgPSB2ZWM0KGxlc3NUaGFuKGIxLDAuMCkpKjIuMCAtIDEuMDtcXG4gIHZlYzQgczAgPSBmbG9vcihiMCkqMi4wICsgMS4wO1xcbiAgdmVjNCBzMSA9IGZsb29yKGIxKSoyLjAgKyAxLjA7XFxuICB2ZWM0IHNoID0gLXN0ZXAoaCwgdmVjNCgwLjApKTtcXG5cXG4gIHZlYzQgYTAgPSBiMC54enl3ICsgczAueHp5dypzaC54eHl5IDtcXG4gIHZlYzQgYTEgPSBiMS54enl3ICsgczEueHp5dypzaC56end3IDtcXG5cXG4gIHZlYzMgcDAgPSB2ZWMzKGEwLnh5LGgueCk7XFxuICB2ZWMzIHAxID0gdmVjMyhhMC56dyxoLnkpO1xcbiAgdmVjMyBwMiA9IHZlYzMoYTEueHksaC56KTtcXG4gIHZlYzMgcDMgPSB2ZWMzKGExLnp3LGgudyk7XFxuXFxuLy9Ob3JtYWxpc2UgZ3JhZGllbnRzXFxuICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXG4gIHAwICo9IG5vcm0ueDtcXG4gIHAxICo9IG5vcm0ueTtcXG4gIHAyICo9IG5vcm0uejtcXG4gIHAzICo9IG5vcm0udztcXG5cXG4vLyBNaXggZmluYWwgbm9pc2UgdmFsdWVcXG4gIHZlYzQgbSA9IG1heCgwLjYgLSB2ZWM0KGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MiksIGRvdCh4Myx4MykpLCAwLjApO1xcbiAgbSA9IG0gKiBtO1xcbiAgcmV0dXJuIDQyLjAgKiBkb3QoIG0qbSwgdmVjNCggZG90KHAwLHgwKSwgZG90KHAxLHgxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdChwMix4MiksIGRvdChwMyx4MykgKSApO1xcbn1cIixcbiAgICAgICAgICBibGVuZDpcbiAgICAgICAgICAgIFwiLy9cXG4vLyBodHRwczovL2dpdGh1Yi5jb20vamFtaWVvd2VuL2dsc2wtYmxlbmRcXG4vL1xcblxcbi8vIE5vcm1hbFxcblxcbnZlYzMgYmxlbmROb3JtYWwodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0cmV0dXJuIGJsZW5kO1xcbn1cXG5cXG52ZWMzIGJsZW5kTm9ybWFsKHZlYzMgYmFzZSwgdmVjMyBibGVuZCwgZmxvYXQgb3BhY2l0eSkge1xcblxcdHJldHVybiAoYmxlbmROb3JtYWwoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBTY3JlZW5cXG5cXG5mbG9hdCBibGVuZFNjcmVlbihmbG9hdCBiYXNlLCBmbG9hdCBibGVuZCkge1xcblxcdHJldHVybiAxLjAtKCgxLjAtYmFzZSkqKDEuMC1ibGVuZCkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kU2NyZWVuKHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiB2ZWMzKGJsZW5kU2NyZWVuKGJhc2UucixibGVuZC5yKSxibGVuZFNjcmVlbihiYXNlLmcsYmxlbmQuZyksYmxlbmRTY3JlZW4oYmFzZS5iLGJsZW5kLmIpKTtcXG59XFxuXFxudmVjMyBibGVuZFNjcmVlbih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kU2NyZWVuKGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gTXVsdGlwbHlcXG5cXG52ZWMzIGJsZW5kTXVsdGlwbHkodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0cmV0dXJuIGJhc2UqYmxlbmQ7XFxufVxcblxcbnZlYzMgYmxlbmRNdWx0aXBseSh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kTXVsdGlwbHkoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBPdmVybGF5XFxuXFxuZmxvYXQgYmxlbmRPdmVybGF5KGZsb2F0IGJhc2UsIGZsb2F0IGJsZW5kKSB7XFxuXFx0cmV0dXJuIGJhc2U8MC41PygyLjAqYmFzZSpibGVuZCk6KDEuMC0yLjAqKDEuMC1iYXNlKSooMS4wLWJsZW5kKSk7XFxufVxcblxcbnZlYzMgYmxlbmRPdmVybGF5KHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiB2ZWMzKGJsZW5kT3ZlcmxheShiYXNlLnIsYmxlbmQuciksYmxlbmRPdmVybGF5KGJhc2UuZyxibGVuZC5nKSxibGVuZE92ZXJsYXkoYmFzZS5iLGJsZW5kLmIpKTtcXG59XFxuXFxudmVjMyBibGVuZE92ZXJsYXkodmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZE92ZXJsYXkoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBIYXJkIGxpZ2h0XFxuXFxudmVjMyBibGVuZEhhcmRMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gYmxlbmRPdmVybGF5KGJsZW5kLGJhc2UpO1xcbn1cXG5cXG52ZWMzIGJsZW5kSGFyZExpZ2h0KHZlYzMgYmFzZSwgdmVjMyBibGVuZCwgZmxvYXQgb3BhY2l0eSkge1xcblxcdHJldHVybiAoYmxlbmRIYXJkTGlnaHQoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBTb2Z0IGxpZ2h0XFxuXFxuZmxvYXQgYmxlbmRTb2Z0TGlnaHQoZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gKGJsZW5kPDAuNSk/KDIuMCpiYXNlKmJsZW5kK2Jhc2UqYmFzZSooMS4wLTIuMCpibGVuZCkpOihzcXJ0KGJhc2UpKigyLjAqYmxlbmQtMS4wKSsyLjAqYmFzZSooMS4wLWJsZW5kKSk7XFxufVxcblxcbnZlYzMgYmxlbmRTb2Z0TGlnaHQodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0cmV0dXJuIHZlYzMoYmxlbmRTb2Z0TGlnaHQoYmFzZS5yLGJsZW5kLnIpLGJsZW5kU29mdExpZ2h0KGJhc2UuZyxibGVuZC5nKSxibGVuZFNvZnRMaWdodChiYXNlLmIsYmxlbmQuYikpO1xcbn1cXG5cXG52ZWMzIGJsZW5kU29mdExpZ2h0KHZlYzMgYmFzZSwgdmVjMyBibGVuZCwgZmxvYXQgb3BhY2l0eSkge1xcblxcdHJldHVybiAoYmxlbmRTb2Z0TGlnaHQoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBDb2xvciBkb2RnZVxcblxcbmZsb2F0IGJsZW5kQ29sb3JEb2RnZShmbG9hdCBiYXNlLCBmbG9hdCBibGVuZCkge1xcblxcdHJldHVybiAoYmxlbmQ9PTEuMCk/YmxlbmQ6bWluKGJhc2UvKDEuMC1ibGVuZCksMS4wKTtcXG59XFxuXFxudmVjMyBibGVuZENvbG9yRG9kZ2UodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuXFx0cmV0dXJuIHZlYzMoYmxlbmRDb2xvckRvZGdlKGJhc2UucixibGVuZC5yKSxibGVuZENvbG9yRG9kZ2UoYmFzZS5nLGJsZW5kLmcpLGJsZW5kQ29sb3JEb2RnZShiYXNlLmIsYmxlbmQuYikpO1xcbn1cXG5cXG52ZWMzIGJsZW5kQ29sb3JEb2RnZSh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kQ29sb3JEb2RnZShiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVxcblxcbi8vIENvbG9yIGJ1cm5cXG5cXG5mbG9hdCBibGVuZENvbG9yQnVybihmbG9hdCBiYXNlLCBmbG9hdCBibGVuZCkge1xcblxcdHJldHVybiAoYmxlbmQ9PTAuMCk/YmxlbmQ6bWF4KCgxLjAtKCgxLjAtYmFzZSkvYmxlbmQpKSwwLjApO1xcbn1cXG5cXG52ZWMzIGJsZW5kQ29sb3JCdXJuKHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiB2ZWMzKGJsZW5kQ29sb3JCdXJuKGJhc2UucixibGVuZC5yKSxibGVuZENvbG9yQnVybihiYXNlLmcsYmxlbmQuZyksYmxlbmRDb2xvckJ1cm4oYmFzZS5iLGJsZW5kLmIpKTtcXG59XFxuXFxudmVjMyBibGVuZENvbG9yQnVybih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kQ29sb3JCdXJuKGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gVml2aWQgTGlnaHRcXG5cXG5mbG9hdCBibGVuZFZpdmlkTGlnaHQoZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHRyZXR1cm4gKGJsZW5kPDAuNSk/YmxlbmRDb2xvckJ1cm4oYmFzZSwoMi4wKmJsZW5kKSk6YmxlbmRDb2xvckRvZGdlKGJhc2UsKDIuMCooYmxlbmQtMC41KSkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kVml2aWRMaWdodCh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHRyZXR1cm4gdmVjMyhibGVuZFZpdmlkTGlnaHQoYmFzZS5yLGJsZW5kLnIpLGJsZW5kVml2aWRMaWdodChiYXNlLmcsYmxlbmQuZyksYmxlbmRWaXZpZExpZ2h0KGJhc2UuYixibGVuZC5iKSk7XFxufVxcblxcbnZlYzMgYmxlbmRWaXZpZExpZ2h0KHZlYzMgYmFzZSwgdmVjMyBibGVuZCwgZmxvYXQgb3BhY2l0eSkge1xcblxcdHJldHVybiAoYmxlbmRWaXZpZExpZ2h0KGJhc2UsIGJsZW5kKSAqIG9wYWNpdHkgKyBiYXNlICogKDEuMCAtIG9wYWNpdHkpKTtcXG59XFxuXFxuLy8gTGlnaHRlblxcblxcbmZsb2F0IGJsZW5kTGlnaHRlbihmbG9hdCBiYXNlLCBmbG9hdCBibGVuZCkge1xcblxcdHJldHVybiBtYXgoYmxlbmQsYmFzZSk7XFxufVxcblxcbnZlYzMgYmxlbmRMaWdodGVuKHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiB2ZWMzKGJsZW5kTGlnaHRlbihiYXNlLnIsYmxlbmQuciksYmxlbmRMaWdodGVuKGJhc2UuZyxibGVuZC5nKSxibGVuZExpZ2h0ZW4oYmFzZS5iLGJsZW5kLmIpKTtcXG59XFxuXFxudmVjMyBibGVuZExpZ2h0ZW4odmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0cmV0dXJuIChibGVuZExpZ2h0ZW4oYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBMaW5lYXIgYnVyblxcblxcbmZsb2F0IGJsZW5kTGluZWFyQnVybihmbG9hdCBiYXNlLCBmbG9hdCBibGVuZCkge1xcblxcdC8vIE5vdGUgOiBTYW1lIGltcGxlbWVudGF0aW9uIGFzIEJsZW5kU3VidHJhY3RmXFxuXFx0cmV0dXJuIG1heChiYXNlK2JsZW5kLTEuMCwwLjApO1xcbn1cXG5cXG52ZWMzIGJsZW5kTGluZWFyQnVybih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG5cXHQvLyBOb3RlIDogU2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBCbGVuZFN1YnRyYWN0XFxuXFx0cmV0dXJuIG1heChiYXNlK2JsZW5kLXZlYzMoMS4wKSx2ZWMzKDAuMCkpO1xcbn1cXG5cXG52ZWMzIGJsZW5kTGluZWFyQnVybih2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kTGluZWFyQnVybihiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVxcblxcbi8vIExpbmVhciBkb2RnZVxcblxcbmZsb2F0IGJsZW5kTGluZWFyRG9kZ2UoZmxvYXQgYmFzZSwgZmxvYXQgYmxlbmQpIHtcXG5cXHQvLyBOb3RlIDogU2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBCbGVuZEFkZGZcXG5cXHRyZXR1cm4gbWluKGJhc2UrYmxlbmQsMS4wKTtcXG59XFxuXFxudmVjMyBibGVuZExpbmVhckRvZGdlKHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdC8vIE5vdGUgOiBTYW1lIGltcGxlbWVudGF0aW9uIGFzIEJsZW5kQWRkXFxuXFx0cmV0dXJuIG1pbihiYXNlK2JsZW5kLHZlYzMoMS4wKSk7XFxufVxcblxcbnZlYzMgYmxlbmRMaW5lYXJEb2RnZSh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQsIGZsb2F0IG9wYWNpdHkpIHtcXG5cXHRyZXR1cm4gKGJsZW5kTGluZWFyRG9kZ2UoYmFzZSwgYmxlbmQpICogb3BhY2l0eSArIGJhc2UgKiAoMS4wIC0gb3BhY2l0eSkpO1xcbn1cXG5cXG4vLyBMaW5lYXIgbGlnaHRcXG5cXG5mbG9hdCBibGVuZExpbmVhckxpZ2h0KGZsb2F0IGJhc2UsIGZsb2F0IGJsZW5kKSB7XFxuXFx0cmV0dXJuIGJsZW5kPDAuNT9ibGVuZExpbmVhckJ1cm4oYmFzZSwoMi4wKmJsZW5kKSk6YmxlbmRMaW5lYXJEb2RnZShiYXNlLCgyLjAqKGJsZW5kLTAuNSkpKTtcXG59XFxuXFxudmVjMyBibGVuZExpbmVhckxpZ2h0KHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcblxcdHJldHVybiB2ZWMzKGJsZW5kTGluZWFyTGlnaHQoYmFzZS5yLGJsZW5kLnIpLGJsZW5kTGluZWFyTGlnaHQoYmFzZS5nLGJsZW5kLmcpLGJsZW5kTGluZWFyTGlnaHQoYmFzZS5iLGJsZW5kLmIpKTtcXG59XFxuXFxudmVjMyBibGVuZExpbmVhckxpZ2h0KHZlYzMgYmFzZSwgdmVjMyBibGVuZCwgZmxvYXQgb3BhY2l0eSkge1xcblxcdHJldHVybiAoYmxlbmRMaW5lYXJMaWdodChiYXNlLCBibGVuZCkgKiBvcGFjaXR5ICsgYmFzZSAqICgxLjAgLSBvcGFjaXR5KSk7XFxufVwiLFxuICAgICAgICAgIGZyYWdtZW50OlxuICAgICAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdl9jb2xvcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMzIGNvbG9yID0gdl9jb2xvcjtcXG4gIGlmICh1X2Rhcmtlbl90b3AgPT0gMS4wKSB7XFxuICAgIHZlYzIgc3QgPSBnbF9GcmFnQ29vcmQueHkvcmVzb2x1dGlvbi54eTtcXG4gICAgY29sb3IuZyAtPSBwb3coc3QueSArIHNpbigtMTIuMCkgKiBzdC54LCB1X3NoYWRvd19wb3dlcikgKiAwLjQ7XFxuICB9XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xcbn1cIixcbiAgICAgICAgfSksXG4gICAgICAgICAgKHRoaXMuY29uZiA9IHtcbiAgICAgICAgICAgIHByZXNldE5hbWU6IFwiXCIsXG4gICAgICAgICAgICB3aXJlZnJhbWU6IGZhbHNlLFxuICAgICAgICAgICAgZGVuc2l0eTogWzAuMDYsIDAuMTZdLFxuICAgICAgICAgICAgem9vbTogMSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICAgICAgcGxheWluZzogdHJ1ZSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiY2FudmFzXCIpLmxlbmd0aCA8IDFcbiAgICAgICAgICAgID8gY29uc29sZS5sb2coXCJESUQgTk9UIExPQUQgSEVSTyBTVFJJUEUgQ0FOVkFTXCIpXG4gICAgICAgICAgICA6ICgodGhpcy5taW5pZ2wgPSBuZXcgTWluaUdsKHRoaXMuZWwsIG51bGwsIG51bGwsICEwKSksXG4gICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbCAmJlxuICAgICAgICAgICAgICAgICAgKCh0aGlzLmNvbXB1dGVkQ2FudmFzU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpKSxcbiAgICAgICAgICAgICAgICAgIHRoaXMud2FpdEZvckNzc1ZhcnMoKSk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgLypcbiAgICAgICAgICB0aGlzLnNjcm9sbE9ic2VydmVyID0gYXdhaXQgcy5jcmVhdGUoLjEsICExKSxcbiAgICAgICAgICB0aGlzLnNjcm9sbE9ic2VydmVyLm9ic2VydmUodGhpcy5lbCksXG4gICAgICAgICAgdGhpcy5zY3JvbGxPYnNlcnZlci5vblNlcGFyYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5oYW5kbGVTY3JvbGwpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLmhhbmRsZU1vdXNlRG93biksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZU1vdXNlVXApLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlEb3duKSwgdGhpcy5pc0ludGVyc2VjdGluZyA9ICExLCB0aGlzLmNvbmYucGxheWluZyAmJiB0aGlzLnBhdXNlKClcbiAgICAgICAgICB9KSwgXG4gICAgICAgICAgdGhpcy5zY3JvbGxPYnNlcnZlci5vbkludGVyc2VjdCgoKSA9PiB7XG4gICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuaGFuZGxlU2Nyb2xsKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5oYW5kbGVNb3VzZURvd24pLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5oYW5kbGVNb3VzZVVwKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5RG93biksIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSAhMCwgdGhpcy5hZGRJc0xvYWRlZENsYXNzKCksIHRoaXMucGxheSgpXG4gICAgICAgICAgfSkqL1xuICAgICAgfVxuICAgICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxPYnNlcnZlciAmJlxuICAgICAgICAgICh3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmhhbmRsZVNjcm9sbCksXG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5oYW5kbGVNb3VzZURvd24pLFxuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZU1vdXNlVXApLFxuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUtleURvd24pLFxuICAgICAgICAgIHRoaXMuc2Nyb2xsT2JzZXJ2ZXIuZGlzY29ubmVjdCgpKSxcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnJlc2l6ZSk7XG4gICAgICB9XG4gICAgICBpbml0TWF0ZXJpYWwoKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgICAgdV90aW1lOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB1X3NoYWRvd19wb3dlcjogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgdmFsdWU6IDEwLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHVfZGFya2VuX3RvcDogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgdmFsdWU6IFwiXCIgPT09IHRoaXMuZWwuZGF0YXNldC5qc0RhcmtlblRvcCA/IDEgOiAwLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHVfYWN0aXZlX2NvbG9yczogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuYWN0aXZlQ29sb3JzLFxuICAgICAgICAgICAgdHlwZTogXCJ2ZWM0XCIsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdV9nbG9iYWw6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgIG5vaXNlRnJlcTogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbdGhpcy5mcmVxWCwgdGhpcy5mcmVxWV0sXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ2ZWMyXCIsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBub2lzZVNwZWVkOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDVlLTYsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGU6IFwic3RydWN0XCIsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdV92ZXJ0RGVmb3JtOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICBpbmNsaW5lOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IE1hdGguc2luKHRoaXMuYW5nbGUpIC8gTWF0aC5jb3ModGhpcy5hbmdsZSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBvZmZzZXRUb3A6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogLTAuNSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG9mZnNldEJvdHRvbTogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiAtMC41LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbm9pc2VGcmVxOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFszLCA0XSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInZlYzJcIixcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG5vaXNlQW1wOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuYW1wLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbm9pc2VTcGVlZDogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiAxMCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG5vaXNlRmxvdzogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiAzLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbm9pc2VTZWVkOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2VlZCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogXCJzdHJ1Y3RcIixcbiAgICAgICAgICAgIGV4Y2x1ZGVGcm9tOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdV9iYXNlQ29sb3I6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNlY3Rpb25Db2xvcnNbMF0sXG4gICAgICAgICAgICB0eXBlOiBcInZlYzNcIixcbiAgICAgICAgICAgIGV4Y2x1ZGVGcm9tOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdV93YXZlTGF5ZXJzOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgICAgICBleGNsdWRlRnJvbTogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBlID0gMTsgZSA8IHRoaXMuc2VjdGlvbkNvbG9ycy5sZW5ndGg7IGUgKz0gMSlcbiAgICAgICAgICB0aGlzLnVuaWZvcm1zLnVfd2F2ZUxheWVycy52YWx1ZS5wdXNoKFxuICAgICAgICAgICAgbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zZWN0aW9uQ29sb3JzW2VdLFxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ2ZWMzXCIsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbm9pc2VGcmVxOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAgICAgICAgICAyICsgZSAvIHRoaXMuc2VjdGlvbkNvbG9ycy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIDMgKyBlIC8gdGhpcy5zZWN0aW9uQ29sb3JzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInZlYzJcIixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBub2lzZVNwZWVkOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogMTEgKyAwLjMgKiBlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5vaXNlRmxvdzogbmV3IHRoaXMubWluaWdsLlVuaWZvcm0oe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IDYuNSArIDAuMyAqIGUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbm9pc2VTZWVkOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zZWVkICsgMTAgKiBlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5vaXNlRmxvb3I6IG5ldyB0aGlzLm1pbmlnbC5Vbmlmb3JtKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiAwLjEsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbm9pc2VDZWlsOiBuZXcgdGhpcy5taW5pZ2wuVW5pZm9ybSh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogMC42MyArIDAuMDcgKiBlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0eXBlOiBcInN0cnVjdFwiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICh0aGlzLnZlcnRleFNoYWRlciA9IFtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyRmlsZXMubm9pc2UsXG4gICAgICAgICAgICB0aGlzLnNoYWRlckZpbGVzLmJsZW5kLFxuICAgICAgICAgICAgdGhpcy5zaGFkZXJGaWxlcy52ZXJ0ZXgsXG4gICAgICAgICAgXS5qb2luKFwiXFxuXFxuXCIpKSxcbiAgICAgICAgICBuZXcgdGhpcy5taW5pZ2wuTWF0ZXJpYWwoXG4gICAgICAgICAgICB0aGlzLnZlcnRleFNoYWRlcixcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyRmlsZXMuZnJhZ21lbnQsXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaW5pdE1lc2goKSB7XG4gICAgICAgICh0aGlzLm1hdGVyaWFsID0gdGhpcy5pbml0TWF0ZXJpYWwoKSksXG4gICAgICAgICAgKHRoaXMuZ2VvbWV0cnkgPSBuZXcgdGhpcy5taW5pZ2wuUGxhbmVHZW9tZXRyeSgpKSxcbiAgICAgICAgICAodGhpcy5tZXNoID0gbmV3IHRoaXMubWluaWdsLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCkpO1xuICAgICAgfVxuICAgICAgc2hvdWxkU2tpcEZyYW1lKGUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAhIXdpbmRvdy5kb2N1bWVudC5oaWRkZW4gfHxcbiAgICAgICAgICAhdGhpcy5jb25mLnBsYXlpbmcgfHxcbiAgICAgICAgICBwYXJzZUludChlLCAxMCkgJSAyID09IDAgfHxcbiAgICAgICAgICB2b2lkIDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUZyZXF1ZW5jeShlKSB7XG4gICAgICAgICh0aGlzLmZyZXFYICs9IGUpLCAodGhpcy5mcmVxWSArPSBlKTtcbiAgICAgIH1cbiAgICAgIHRvZ2dsZUNvbG9yKGluZGV4KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ29sb3JzW2luZGV4XSA9IDAgPT09IHRoaXMuYWN0aXZlQ29sb3JzW2luZGV4XSA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgc2hvd0dyYWRpZW50TGVnZW5kKCkge1xuICAgICAgICB0aGlzLndpZHRoID4gdGhpcy5taW5XaWR0aCAmJlxuICAgICAgICAgICgodGhpcy5pc0dyYWRpZW50TGVnZW5kVmlzaWJsZSA9ICEwKSxcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJpc0dyYWRpZW50TGVnZW5kVmlzaWJsZVwiKSk7XG4gICAgICB9XG4gICAgICBoaWRlR3JhZGllbnRMZWdlbmQoKSB7XG4gICAgICAgICh0aGlzLmlzR3JhZGllbnRMZWdlbmRWaXNpYmxlID0gITEpLFxuICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImlzR3JhZGllbnRMZWdlbmRWaXNpYmxlXCIpO1xuICAgICAgfVxuICAgICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5pbml0R3JhZGllbnRDb2xvcnMoKSxcbiAgICAgICAgICB0aGlzLmluaXRNZXNoKCksXG4gICAgICAgICAgdGhpcy5yZXNpemUoKSxcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKSxcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnJlc2l6ZSk7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICogV2FpdGluZyBmb3IgdGhlIGNzcyB2YXJpYWJsZXMgdG8gYmVjb21lIGF2YWlsYWJsZSwgdXN1YWxseSBvbiBwYWdlIGxvYWQgYmVmb3JlIHdlIGNhbiBjb250aW51ZS5cbiAgICAgICAqIFVzaW5nIGRlZmF1bHQgY29sb3JzIGFzc2lnbmVkIGJlbG93IGlmIG5vIHZhcmlhYmxlcyBoYXZlIGJlZW4gZm91bmQgYWZ0ZXIgbWF4Q3NzVmFyUmV0cmllc1xuICAgICAgICovXG4gICAgICB3YWl0Rm9yQ3NzVmFycygpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuY29tcHV0ZWRDYW52YXNTdHlsZSAmJlxuICAgICAgICAgIC0xICE9PVxuICAgICAgICAgICAgdGhpcy5jb21wdXRlZENhbnZhc1N0eWxlXG4gICAgICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1ncmFkaWVudC1jb2xvci0xXCIpXG4gICAgICAgICAgICAgIC5pbmRleE9mKFwiI1wiKVxuICAgICAgICApXG4gICAgICAgICAgdGhpcy5pbml0KCksIHRoaXMuYWRkSXNMb2FkZWRDbGFzcygpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoKHRoaXMuY3NzVmFyUmV0cmllcyArPSAxKSxcbiAgICAgICAgICAgIHRoaXMuY3NzVmFyUmV0cmllcyA+IHRoaXMubWF4Q3NzVmFyUmV0cmllcylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh0aGlzLnNlY3Rpb25Db2xvcnMgPSBbMTY3MTE2ODAsIDE2NzExNjgwLCAxNjcxMTkzNSwgNjUyODAsIDI1NV0pLFxuICAgICAgICAgICAgICB2b2lkIHRoaXMuaW5pdCgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy53YWl0Rm9yQ3NzVmFycygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLypcbiAgICAgICAqIEluaXRpYWxpemVzIHRoZSBmb3VyIHNlY3Rpb24gY29sb3JzIGJ5IHJldHJpZXZpbmcgdGhlbSBmcm9tIGNzcyB2YXJpYWJsZXMuXG4gICAgICAgKi9cbiAgICAgIGluaXRHcmFkaWVudENvbG9ycygpIHtcbiAgICAgICAgdGhpcy5zZWN0aW9uQ29sb3JzID0gW1xuICAgICAgICAgIFwiLS1ncmFkaWVudC1jb2xvci0xXCIsXG4gICAgICAgICAgXCItLWdyYWRpZW50LWNvbG9yLTJcIixcbiAgICAgICAgICBcIi0tZ3JhZGllbnQtY29sb3ItM1wiLFxuICAgICAgICAgIFwiLS1ncmFkaWVudC1jb2xvci00XCIsXG4gICAgICAgIF1cbiAgICAgICAgICAubWFwKChjc3NQcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgICAgIGxldCBoZXggPSB0aGlzLmNvbXB1dGVkQ2FudmFzU3R5bGVcbiAgICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUoY3NzUHJvcGVydHlOYW1lKVxuICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgICAgICAgLy9DaGVjayBpZiBzaG9ydGhhbmQgaGV4IHZhbHVlIHdhcyB1c2VkIGFuZCBkb3VibGUgdGhlIGxlbmd0aCBzbyB0aGUgY29udmVyc2lvbiBpbiBub3JtYWxpemVDb2xvciB3aWxsIHdvcmsuXG4gICAgICAgICAgICBpZiAoNCA9PT0gaGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCBoZXhUZW1wID0gaGV4XG4gICAgICAgICAgICAgICAgLnN1YnN0cigxKVxuICAgICAgICAgICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAgICAgICAgIC5tYXAoKGhleFRlbXApID0+IGhleFRlbXAgKyBoZXhUZW1wKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICBoZXggPSBgIyR7aGV4VGVtcH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhleCAmJiBgMHgke2hleC5zdWJzdHIoMSl9YDtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAubWFwKG5vcm1hbGl6ZUNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqRmluYWxseSBpbml0aWFsaXppbmcgdGhlIEdyYWRpZW50IGNsYXNzLCBhc3NpZ25pbmcgYSBjYW52YXMgdG8gaXQgYW5kIGNhbGxpbmcgR3JhZGllbnQuY29ubmVjdCgpIHdoaWNoIGluaXRpYWxpemVzIGV2ZXJ5dGhpbmcsXG4gICAgICogVXNlIEdyYWRpZW50LnBhdXNlKCkgYW5kIEdyYWRpZW50LnBsYXkoKSBmb3IgY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBIZXJlIGFyZSBzb21lIGRlZmF1bHQgcHJvcGVydHkgdmFsdWVzIHlvdSBjYW4gY2hhbmdlIGFueXRpbWU6XG4gICAgICogQW1wbGl0dWRlOiAgICBHcmFkaWVudC5hbXAgPSAwXG4gICAgICogQ29sb3JzOiAgICAgICBHcmFkaWVudC5zZWN0aW9uQ29sb3JzIChpZiB5b3UgY2hhbmdlIGNvbG9ycywgdXNlIG5vcm1hbGl6ZUNvbG9yKCNoZXhWYWx1ZSkpIGJlZm9yZSB5b3UgYXNzaWduIGl0LlxuICAgICAqXG4gICAgICpcbiAgICAgKiBVc2VmdWwgZnVuY3Rpb25zXG4gICAgICogR3JhZGllbnQudG9nZ2xlQ29sb3IoaW5kZXgpXG4gICAgICogR3JhZGllbnQudXBkYXRlRnJlcXVlbmN5KGZyZXEpXG4gICAgICovXG4gICAgdmFyIGdyYWRpZW50ID0gbmV3IEdyYWRpZW50KCk7XG4gICAgZ3JhZGllbnQuaW5pdEdyYWRpZW50KFwiI2dyYWRpZW50LWNhbnZhc1wiKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxjYW52YXNcbiAgICAgICAgaWQ9XCJncmFkaWVudC1jYW52YXNcIlxuICAgICAgICAvLyAgIHN0eWxlPVwid2lkdGg6MTAwdnc7aGVpZ2h0OjEwMHZoXCJcbiAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGgtc2NyZWVuXCJcbiAgICAgID48L2NhbnZhcz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RyaXBlO1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsIlN0cmlwZSIsIm5vcm1hbGl6ZUNvbG9yIiwiaGV4Q29kZSIsInJlZHVjZSIsInQiLCJuIiwiT2JqZWN0IiwiYXNzaWduIiwiTWluaUdsIiwic2V0U2l6ZSIsImUiLCJ3aWR0aCIsImhlaWdodCIsImNhbnZhcyIsImdsIiwidmlld3BvcnQiLCJjb21tb25Vbmlmb3JtcyIsInJlc29sdXRpb24iLCJ2YWx1ZSIsImFzcGVjdFJhdGlvIiwiZGVidWciLCJzZXRPcnRob2dyYXBoaWNDYW1lcmEiLCJpIiwicyIsInByb2plY3Rpb25NYXRyaXgiLCJyZW5kZXIiLCJjbGVhckNvbG9yIiwiY2xlYXJEZXB0aCIsIm1lc2hlcyIsImZvckVhY2giLCJkcmF3IiwiY29uc3RydWN0b3IiLCJfbWluaUdsIiwiZGVidWdfb3V0cHV0IiwiZG9jdW1lbnQiLCJsb2NhdGlvbiIsInNlYXJjaCIsInRvTG93ZXJDYXNlIiwiaW5kZXhPZiIsImdldENvbnRleHQiLCJhbnRpYWxpYXMiLCJjb250ZXh0IiwibGFzdERlYnVnTXNnIiwiRGF0ZSIsImNvbnNvbGUiLCJsb2ciLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJBcnJheSIsIk1hdGgiLCJtYXgiLCJsZW5ndGgiLCJqb2luIiwiZnJvbSIsImFyZ3VtZW50cyIsInNsaWNlIiwiZGVmaW5lUHJvcGVydGllcyIsIk1hdGVyaWFsIiwiZW51bWVyYWJsZSIsImF0dGFjaFVuaWZvcm1zIiwibmFtZSIsInVuaWZvcm1zIiwibWF0ZXJpYWwiLCJlbnRyaWVzIiwidW5pZm9ybSIsInR5cGUiLCJ1bmlmb3JtSW5zdGFuY2VzIiwicHVzaCIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInByb2dyYW0iLCJ2ZXJ0ZXhTaGFkZXJzIiwiZnJhZ21lbnRzIiwiZ2V0U2hhZGVyQnlUeXBlIiwic291cmNlIiwic2hhZGVyIiwiY3JlYXRlU2hhZGVyIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiZXJyb3IiLCJnZXRTaGFkZXJJbmZvTG9nIiwiZ2V0VW5pZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25zIiwibWFwIiwiZ2V0RGVjbGFyYXRpb24iLCJwcmVmaXgiLCJ2ZXJ0ZXhTb3VyY2UiLCJTb3VyY2UiLCJ2ZXJ0ZXhTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiZnJhZ21lbnRTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJjcmVhdGVQcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJnZXRQcm9ncmFtSW5mb0xvZyIsInVzZVByb2dyYW0iLCJVbmlmb3JtIiwidXBkYXRlIiwidHlwZUZuIiwidHJhbnNwb3NlIiwiZXhjbHVkZUZyb20iLCJuYW1lX25vX3ByZWZpeCIsInJlcGxhY2UiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsImZsb2F0IiwiaW50IiwidmVjMiIsInZlYzMiLCJ2ZWM0IiwibWF0NCIsIlBsYW5lR2VvbWV0cnkiLCJzZXRUb3BvbG9neSIsInhTZWdDb3VudCIsInlTZWdDb3VudCIsInZlcnRleENvdW50IiwicXVhZENvdW50IiwiYXR0cmlidXRlcyIsInV2IiwidmFsdWVzIiwiRmxvYXQzMkFycmF5IiwidXZOb3JtIiwiaW5kZXgiLCJVaW50MTZBcnJheSIsIm9yaWVudGF0aW9uIiwiZ2VvbWV0cnkiLCJwb3NpdGlvbiIsIm8iLCJyIiwic2VnbWVudF93aWR0aCIsInNlZ21lbnRfaGVpZ2h0IiwieUluZGV4IiwieEluZGV4IiwibCIsImNyZWF0ZUJ1ZmZlciIsIkF0dHJpYnV0ZSIsInRhcmdldCIsIkFSUkFZX0JVRkZFUiIsInNpemUiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsIlVOU0lHTkVEX1NIT1JUIiwiTWVzaCIsImF0dHJpYnV0ZUluc3RhbmNlcyIsImF0dHJpYnV0ZSIsInVzZSIsImRyYXdFbGVtZW50cyIsIndpcmVmcmFtZSIsIkxJTkVTIiwiVFJJQU5HTEVTIiwicmVtb3ZlIiwiZmlsdGVyIiwibWVzaCIsImF0dGFjaCIsImJpbmRCdWZmZXIiLCJidWZmZXIiLCJidWZmZXJEYXRhIiwiU1RBVElDX0RSQVciLCJnZXRBdHRyaWJMb2NhdGlvbiIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIm5vcm1hbGl6ZWQiLCJGTE9BVCIsImEiLCJtb2RlbFZpZXdNYXRyaXgiLCJvYmplY3QiLCJwcm9wZXJ0eU5hbWUiLCJ2YWwiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiR3JhZGllbnQiLCJjb25uZWN0Iiwic2hhZGVyRmlsZXMiLCJ2ZXJ0ZXgiLCJub2lzZSIsImJsZW5kIiwiZnJhZ21lbnQiLCJjb25mIiwicHJlc2V0TmFtZSIsImRlbnNpdHkiLCJ6b29tIiwicm90YXRpb24iLCJwbGF5aW5nIiwicXVlcnlTZWxlY3RvckFsbCIsIm1pbmlnbCIsImVsIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY29tcHV0ZWRDYW52YXNTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJ3YWl0Rm9yQ3NzVmFycyIsImRpc2Nvbm5lY3QiLCJzY3JvbGxPYnNlcnZlciIsIndpbmRvdyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVTY3JvbGwiLCJoYW5kbGVNb3VzZURvd24iLCJoYW5kbGVNb3VzZVVwIiwiaGFuZGxlS2V5RG93biIsInJlc2l6ZSIsImluaXRNYXRlcmlhbCIsInVfdGltZSIsInVfc2hhZG93X3Bvd2VyIiwidV9kYXJrZW5fdG9wIiwiZGF0YXNldCIsImpzRGFya2VuVG9wIiwidV9hY3RpdmVfY29sb3JzIiwiYWN0aXZlQ29sb3JzIiwidV9nbG9iYWwiLCJub2lzZUZyZXEiLCJmcmVxWCIsImZyZXFZIiwibm9pc2VTcGVlZCIsInVfdmVydERlZm9ybSIsImluY2xpbmUiLCJzaW4iLCJhbmdsZSIsImNvcyIsIm9mZnNldFRvcCIsIm9mZnNldEJvdHRvbSIsIm5vaXNlQW1wIiwiYW1wIiwibm9pc2VGbG93Iiwibm9pc2VTZWVkIiwic2VlZCIsInVfYmFzZUNvbG9yIiwic2VjdGlvbkNvbG9ycyIsInVfd2F2ZUxheWVycyIsImNvbG9yIiwibm9pc2VGbG9vciIsIm5vaXNlQ2VpbCIsImluaXRNZXNoIiwic2hvdWxkU2tpcEZyYW1lIiwiaGlkZGVuIiwicGFyc2VJbnQiLCJ1cGRhdGVGcmVxdWVuY3kiLCJ0b2dnbGVDb2xvciIsInNob3dHcmFkaWVudExlZ2VuZCIsIm1pbldpZHRoIiwiaXNHcmFkaWVudExlZ2VuZFZpc2libGUiLCJib2R5IiwiY2xhc3NMaXN0IiwiYWRkIiwiaGlkZUdyYWRpZW50TGVnZW5kIiwiaW5pdCIsImluaXRHcmFkaWVudENvbG9ycyIsImFuaW1hdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImFkZElzTG9hZGVkQ2xhc3MiLCJjc3NWYXJSZXRyaWVzIiwibWF4Q3NzVmFyUmV0cmllcyIsImNzc1Byb3BlcnR5TmFtZSIsImhleCIsInRyaW0iLCJoZXhUZW1wIiwic3Vic3RyIiwic3BsaXQiLCJCb29sZWFuIiwiY2xlYXJUaW1lb3V0Iiwic2Nyb2xsaW5nVGltZW91dCIsInNldFRpbWVvdXQiLCJoYW5kbGVTY3JvbGxFbmQiLCJzY3JvbGxpbmdSZWZyZXNoRGVsYXkiLCJpc1Njcm9sbGluZyIsInBhdXNlIiwiaXNJbnRlcnNlY3RpbmciLCJwbGF5IiwiaW5uZXJXaWR0aCIsImNlaWwiLCJpc01ldGFLZXkiLCJtZXRhS2V5IiwiaXNNb3VzZURvd24iLCJtaW4iLCJsYXN0IiwiaXNTdGF0aWMiLCJpc0xvYWRlZENsYXNzIiwicGFyZW50RWxlbWVudCIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsImdyYWRpZW50IiwiaW5pdEdyYWRpZW50IiwiZGl2IiwiaWQiLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/Stripe.js\n"));

/***/ })

});